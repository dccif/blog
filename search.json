[{"title":"QT 6.2 msvc 2019 下 静态编译","url":"/2021/11/11/QT-6-2-msvc-2019-静态编译/","content":"\n# 环境准备\n\nQT 6版本全面换成了CMake，Win下环境需要\n\nCMake, Ninja, Perl, Python [官网要求](https://doc.qt.io/qt-6/windows-building.html)\n\n| **Tool** | **Supported Versions**                                       | **Description**                                              |\n| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| CMake    | Version 3.16 and newer (3.17 and newer for `-debug-and-release` builds 3.21 and newer for `-static` builds). | Required for configuring the Qt build. Available in the Qt Online Installer and on [cmake.org](https://cmake.org/). |\n| Ninja    | \\-                                                           | Recommended tool for building Qt. Available in the Qt Online Installer and on [ninja-build.org](https://ninja-build.org/). |\n| Perl     | \\-                                                           | Required build tool. Popular Windows installers are [ActiveState Perl](https://www.activestate.com/products/perl/downloads/) and [Strawberry Perl](https://strawberryperl.com/). Perl is also installed as part of [Git](https://git-scm.com/download/win). |\n| Python   | Version 3                                                    | Required build tool. Windows installers are available on [python.org](https://www.python.org/downloads/windows/), or from the [Microsoft Store](https://docs.python.org/3/using/windows.html#windows-store). |\n\n关于Perl 个人推荐 [Strawberry Perl](https://strawberryperl.com/) 版本新，安装方便。缺工具就去下，全部环境变量中配置好就行\n\n<!--more-->\n\n### 编译环境选择：MinGW/MSVC\n\n在Windows上，有两个预构建环境可供选择：一个是 MinGW ，另一个是Microsoft Visual Studio(MSVC)。这两个环境不兼容，无法混合。你必须选择一个。\n\n这两者的区别如下：\n\n当你的项目使用MinGW编译的使用，想要用一个MSVC编译生成的库时就会有问题。使用MinGW编译项目的时候，所使用的Lib也要是MinGW编译的。如果你只是开发Window平台的软件时，最好用Qt MSVC组合，这样可以使用大量的第三方lib，还有很多的构建指令，毕竟window上MSVC才是王道。\n\n我选择MSVC，打开安装VS时自带安装的MSCV：`x64 Native Tools Command Prompt for VS 2019`\n\n*不要使用 Developer Command Prompt for VS 2019*\n\n## 编译\n\n在随便什么盘里新建一个目录用来存放编译好的内容：`D:\\qt`\n\n在`x64 Native Tools Command Prompt for VS 2019`的终端进入Qt源代码目录：\n\n```\nC:\\Users\\peter\\Downloads>cd qt-everywhere-src-5.15.0\n\nC:\\Users\\peter\\Downloads\\qt-everywhere-src-5.15.0>\n```\n\n### ~~（不推荐,可跳过）1.修改源码里的`qtbase\\mkspecs\\common\\msvc-desktop.conf`文件~~\n\n修改-MD为-MT\n\n修改前：\n\n```\nQMAKE_CFLAGS_RELEASE    = $$QMAKE_CFLAGS_OPTIMIZE -MD\nQMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -Zi -MD\nQMAKE_CFLAGS_DEBUG      = -Zi -MDd\n```\n\n修改后：\n\n```\nQMAKE_CFLAGS_RELEASE    = $$QMAKE_CFLAGS_OPTIMIZE -MT\nQMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO += $$QMAKE_CFLAGS_OPTIMIZE -Zi -MT\nQMAKE_CFLAGS_DEBUG      = -Zi -MTd\n```\n\nD的意思是动态编译(dynamic link)，T的意思是静态编译（static link）。 这一步官方教程没有要求\n\n目的仅有让编译出来的Win上静态文件是最小的（不推荐使用）会导致example等动态链接的库无法使用编译好的静态QT编译\n\n### 配置config文件：\n\n主要需要在 VS 2019的命令行中运行，如果一次配置不通过，出错下一次也是无法通过的，因为有`CMakeCache.txt` 文件，需要删除上一步失败的`CMakeCache.txt`文件\n\n我的配置文件：\n\n```shell\nconfigure.bat -static -prefix \"D:\\qt\" -confirm-license -opensource -debug-and-release -platform win32-msvc -optimize-size -no-pch -nomake examples -nomake tests -nomake tools -plugin-sql-sqlite -plugin-sql-odbc -qt-zlib -qt-libpng -qt-freetype -qt-pcre -qt-harfbuzz -qt-libjpeg -opengl desktop -mp\n```\n\n具体含义如下：\n\n```shell\nconfigure.bat \n-static  #指明静态编译\n-prefix \"D:\\qt\" #安装目录，最好使用不需要管理员权限的目录\n-confirm-license -opensource #指明是开源版本\n-debug-and-release #指明需要debug版和release版，可以单独选择release版\n-platform win32-msvc #指明使用msvc编译，这里的win32并不指32位\n-optimize-size #最优化文件大小而不是速度(可选)\n-no-pch #不使用预编译头文件（可选）\n-nomake examples -nomake tests -nomake tools #不编译用不上的东西\n-plugin-sql-sqlite -plugin-sql-odbc -qt-zlib -qt-libpng -qt-freetype -qt-pcre -qt-harfbuzz -qt-libjpeg #可选插件\n-opengl desktop  #用系统自带的opengl\n-mp #多核编译\n```\n\n如果无报错\n\n接着运行\n\n```\ncmake --build . ---parallel //编译本目录，parallel为并行，即多核心编译\ncmake --install . //安装命令\n```\n\n## 配置QtCreator\n\nQt version 下找到刚才编译的`bin/qmake.exe`\n\nKits下选择刚才的Qt version 注意编译器选择需要和上面编译时使用的一样\n\n至此，编译完成\n\n## 测试大小\n\n选择release模式编译，等待编译完成后打开编译文件夹，即可看到编译后的文件大小大约12.7MB\n\n如果是动态编译，再使用`windeployqt`个人测试的大小是78MB左右，所以还是静态编译时省事\n\n## 参考\n\n最后感谢这些文章的作者，Thanks\n\n[Qt5.15在Windows环境静态编译安装和部署的完整过程 VS 2019-Qt static link build Windows 64 bit](https://last2win.com/qt-5.15-static-link/)\n\n[使用MSVC2019静态编译生成Qt库](https://aymetic.com/post/2273ab9c.html)\n\n[At last, let's build Qt statically](https://decovar.dev/blog/2018/02/17/build-qt-statically/)\n","tags":["环境搭建","编程","QT","C++"],"categories":["编程"]},{"title":"博客的一键部署2","url":"/2021/11/07/博客的一键部署2/","content":"\n# 博客的一键部署2\n\n承接以前的 [**博客的一键部署**](https://blog.dccif.top/2017/11/27/%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/)\n\n时隔几年，我又开始写博客了，这次一开始还是纠结了是选用传统的动态博客还是静态博客，考虑的价钱和安全性的问题，可能还是静态博客更适合我目前的阶段\n\n\n\n## 曾经的一键部署不好用了吗？\n\n的确曾经我的一键部署把简单的问题复杂了，想着利用一个仓库的两个分支保存原始文件和生成文件。的确这没有问题，目前我的博客也是这个方式，但是有问题的是我过去的整个工作流程。曾经我的流程完全和现在相反，难怪当初的用法那么难受😂\n\n\n\n## 现在的方法\n\n用现在Modern一点的词来说，就是现在使用了**持续集成 ( Continuous integration )**, 毕竟博客这种*项目*也算一种**持续交付（Continuous delivery）**，**持续部署（continuous deployment）**，只不过现在我只需写文章，然后推送，现代的在线工具就可以完成部署任务了，可以说能让我更专注于写作了。不过如果要长时间保持产出干货文章还是有点难度的啊，还是评说评说游戏什么的好了🤣\n","tags":["环境搭建"],"categories":["编程"]},{"title":"甘雨骗局","url":"/2021/05/09/甘雨骗局/","content":"\n# **随着难度的提高，其实月卡平民不该硬练(投入过量资源)甘雨**\n\n随着活动的结束，和深渊“开荒”的结束，很多玩家无脑吹上了甘雨，但是我认为甘雨其实是最不平民的角色，她是给平民保下限的角色。\n如果难度进一步增大，可能一些0命上限高的角色才是最适合月卡平民的。现在新出的优菈，胡桃，公子论dps是平民手上最强的\n\n首先我给出平民的定义: 满精4星武器0命5星角色，拿着5星武器甚至专属武器的就不要来“代入”了\n\n## 甘雨不适合平民的理由：\n\n<!--more-->\n\n### 1. 甘雨的提升难\n\n   练过的玩家肯定知道所谓的“一箭”多少w的提升有多难，冰套的“垃圾”词条有多少，乐团还没有稳定的获取途径。而且就算你阳寿，我们看武器都能看出，阿莫斯的精炼提升有多高，高精阿莫斯一箭大约能8w，而平民4w可能都难，逼真大佬的输出是平民的2倍。\n\n   有人就说了，其他角色也这样啊？可是问题就是其他反应角色可以依靠反应“拉近”和氪佬的距离，而甘雨单射的时候就和氪金多少有关系。\n   举一下那些核弹角色的例子，莫娜，公子，胡桃这几位，因为现在就能轻松打反应，所以哪怕平民玩家也能打出“大数字”。\n   大数字是有一定意义的，因为一般深渊难的怪就1，2只，靠大数字秒了，就是能不能过，和超不超时的区别。\n   现版本因为配套设施的问题，甘雨打融化并不容易，或者说比较别扭，既没全火力(吃满阿莫斯)的队友，也没融化冰套，只能捡“阳寿”圣遗物。\n\n\n\n### 2. 甘雨的队友难\n\n   大家都知道莫甘温娜的阵容，可是同样的主c阵容里，甘雨需要的队友是5星最多的，她需要的那位四星还是可有可无的。其他的主c都没她这么高的队友要求。\n\n   而另一种双火融化流，可能也需要钟离或者盾角色。比起其他主c全靠完善的4星就能配，她其实是最吃队友的。\n\n\n\n### 3. 甘雨的操作难\n   手机上蓄力射击有多难，不用多说了吧。可是同样别的主c手机上也能方便玩，pc上也方便。你说玩大招流，可是莫甘温娜终究是看ch愿不愿意抬和限制的问题，这阵容对单，比如1.6的古岩龙蜥就等于没有。\n\n\n\n### 4. 平民甘雨站场射击dps并不高\n   如果全程只靠平民甘雨战场射击，就算你弹无虚发，算下来的dps可能就2w射击+ 冰锥的1w，总计3w左右。\n   这里说的是dps：射击4w，需要1.8s，实战一般要2s，冰锥一般6000，实战1s3下左右，dps相加3w8\n   这是在一个4人游戏，可能还需要一个套盾人。意味着平民玩家让甘雨单战场需要吃2个队伍的位置，换来的dps就3w，而这个dps是很多2人角色都可以轻松超过的。\n   不和dps天花板胡桃比，就和迪卢克或者可莉比，其实都没优势。比如迪卢克，因为依靠平a可以触发后台副c，最典型的就是行秋。可莉走a重也能接近。\n   甘雨蓄力重击在平民玩家手上是不如高练后台2人的，最关键的上面的1点，平民甘雨提升难，其他能搭配副c的角色，提升输出难度就比甘雨容易。\n\n\n\n### 5. 平民甘雨不主c当后台冰工具人还不行了？\n   首先现在后台冰工具人的用途不算大，也不算抢手，不然早在开服时候为什么大家不练起来凯亚呢？而且平民甘雨要“无缝”大是需要堆充能的，势必会让dps更低。在不聚怪的情况下，平民甘雨可能q对单的总伤有10w左右，这输出分配到15s里，dps就7000左右，这个dps其实高练度的脱手，比如大家总“看不上”的阿贝多，都能做到。\n\n\n\n### 6. 甘雨可能是命座拆分最大的角色之一\n   不知道为什么甘雨命座竟然没“节奏”，也许只是大家看0命“大数字”就觉得强了吧。\n   甘雨命座藏了充能，生存，辅助，爆发。最关键的是爆发，当初迪卢克为什么被大家说呢？不就是爆发低了吗，甘雨把“爆发”机制藏进了命座。而其他的限定五星C 0命基本上都是又能爆发又能站场的。\n\n\n\n## 总结\n综上，甘雨吹们和平民玩家都冷静一点，平民配置下的她强度可能是跟不上“璃月3C”的名号的，也不是所谓的有了能解决一切烦恼的角色。\n\n那些还没甘雨的玩家也别因为“复刻”时真有了，感觉和“想象”中有差距就好了。\n\n真正适合平民的队伍可能还是高命的4星队伍，因为高命4星命座有伤害也有机制和配合，打过一个0命5星的队伍现在也不是什么稀奇的事吧。\n","tags":["角色评价","理解交流"],"categories":["原神"]},{"title":"小谈绘画中的RGB与HSB(V)","url":"/2020/07/27/小谈绘画中的RGB与HSB(V) /","content":"\n# 开篇一段废话：\n\n看了网络上的关于数字绘画，图层混合模式还有所谓的不同色彩空间的描述，感觉还是不够满意，便有了这篇文章，本人才疏学浅，试图从原理上说明一下，如有疏漏和错误，还是请真大佬来指出了吧。以下都是本人个人闭门造车的一些经验。\n\n# 首先什么是RGB,HSB(V)：\n\n能点进来看的人，多半这两个都是知道的吧。但是这两本质是一个“**色彩空间**”，只不过HSB(V)是RGB的另一种坐标表达方式。但是绘画中还是HSB(V)好用，但是图层混合模式中使用的又是RGB，这反正就使得我个人对使用HSB(V)颜色时对图层混合的不断“试错”。\n\n归根到底还是要知道RGB<->HSB(V) 到底发生了什么\n\n<!--more-->\n\n![RGB to HSV](/image/draw/rgbtohsv.webp)\n\n最快方式就是看公式。\n\n看$RGB \\to HSB(V)$的公式，很快我们能发现S和V的值的定义。\n\n**$S=\\frac{（最亮光-最暗光）} {最亮光}$**\n\n**V简单明了，就是当前最亮光的值。**\n\n我个人感觉知道这两就够了，特别是B(V)值得由来，毕竟绘画时也是这个最重要。\n\n这样随便一个RGB的颜色的明度都能“脑内”换算了。整一个图的明度也知道依照的是什么了。\n\nHSB(V)->RGB公式的实用意义不大，我也就不列了\n\n所以最重要的结论便是 **RGB中最亮的光就是当前颜色的明度。饱和度是最亮光与最暗光的差值与最亮光的比值**\n\n# 色彩与明度的关系：\n\n不同的颜色会给人产生不同的明度感。比如下图\n\n![hue and value](/image/draw/hueandvalue.webp)\n\n这种明度感，我们可以通过转换成灰度，一下就能看出\n\n![gray and value](/image/draw/grayandvalue.webp)\n\n明明RGB上一样光数值的颜色，为什么给人的“明度”感不一样呢？\n\n说到底颜色就是一种幻觉，一切颜色不过是电磁波打在了视锥，视杆细胞上产生了电信号后经大脑处理后产生的罢了。\n\n![eyeball and color](/image/draw/eyeballandcolor.webp)\n\n一张图就能说明一切，因为人眼对不同光线的“灵敏度”不同。\n\n举上面的黄光为例，人之所为看到黄光，本质是绿色视锥细胞和红色视锥细胞被激活了，这两细胞被激活的同时，感受“明度”的视杆细胞同时被两种“光线”刺激，很显然就会觉得“明度”高了。\n\n这就可以得出结论**哪怕RGB上同明度的混合色，人眼感知明度也比同明度的原色高。**\n\n# 图层混合模式：\n\n说到绘画中最常用的模式，多半还是Multiply/正片叠底/色彩增值 和 Screen/滤色了。一个是变暗，一个是加亮\n\nMultiply/正片叠底/色彩增值：直接2种颜色相乘，公式网上都是。因为最亮的白色是1，所以1*任何颜色 = 任何颜色，这样就能去白留黑。\n\n然而在绘画中，多半是用来绘制阴影。与其用中性灰来压暗，绘画中可能更多的是**使用光线的颜色来直接绘制“带颜色”的阴影**。直接使用光线的颜色，这样的阴影还会有光源的颜色信息，因为都是比例，两个小数会越乘越小。\n\nScreen/滤色：其实同理，只不过是两个颜色的“负片”正片叠底后再负片。负片越暗再负片就越亮，同理**直接使用光源的颜色，能反映出光源信息。**\n\n# 总结\n\n写这种多本质还是想说绘画时其实也可以通过RGB思考颜色，并不一定总是HSB(V)，通过RGB思考颜色，还能比较方便的转换到CMYK的手绘上，毕竟颜色的本质都是反射多少光线。\n\n# 附：RGB->HSV的3维过程\n\n![RGB to HSV in 3D](/image/draw/rgbtohsv3d.webp)","tags":["绘画"],"categories":["随想"]},{"title":"关于《疯狂系列》","url":"/2018/02/24/关于《疯狂系列》/","content":"\n# 关于《疯狂系列》\n\n首先感谢李刚老师的《疯狂HTML5》的一书，本文以下的内容也是基于这本目前我看完的书得出的，作为对比的是《Head First HTML5》。\n\n下面我就从我暂时能想到的几个方面来谈谈这本《疯狂HTML5》或者同样的《疯狂系列》和《Head Fist》系列的对比吧。\n\n<!--more-->\n\n## 目标受众\n\n很多人评价书时没有注意到这本书是写个谁的，举个不恰当的例子，就像小学生买了高数书，然后说这本书不好，这样对书的评价我觉得是不客观的，也是不公平的，我竟然从这两个系列面向的不同的受众说说吧，当然本来我的水平也不高😅\n\n\n|      《疯狂系列》      | 《Head First》 |\n| :--------------------: | :------------: |\n| 已经从事软件开发的人员 | 还未入门的人士 |\n\n这不是我说的，是这两本书前言自己写的。\n\n所以有人拿着一本《疯狂系列》然后说没法入门，是本~~垃圾~~书我个人觉得是有失客观的。\n\n## 内容深度和广度\n\n说到一本入门级的书，到底要到什么程度？每个人有自己的看法，但是就书的广度来说，《疯狂系列》不愧是看完之后还能作作参考书的“入门书”，而《Head First》更像一个领路人，告诉读者这里可以这样，原理是什么。\n\n所以就我看的这一本来说\n\n深度：《疯狂》部分 <≈，其余 >《Head First》\n\n广度：《疯狂》>《Head First》\n\n### 暂时的结语\n\n所以如果我推荐，还是两本都看看，不重要的可以先跳过，但是《Head First》要先看，之后再看《疯狂系统》\n\n当然最好的入门还是best practices，在做的过程中学得最快。","tags":["编程","阅读"],"categories":["随想"]},{"title":"致过去的一年","url":"/2018/01/02/致过去的一年/","content":"\n# 致过去的一年\n\n眨眼间，2017就过去了，回首这一年，也许我最大的收获就是发现了自己有多弱了吧。从编译到算法，从语言到实现，我看上去每一门都知道那么一点，可是却又都不都不深入，也没自己实现过大一点的项目。","tags":["闲谈"],"categories":["随想"]},{"title":"近期随想","url":"/2017/12/18/近期随想/","content":"\n# 近期的随想\n\n自从我上次写好一键脚本后，过了快半个月，我却完全没有因为有了方便的脚本而增加写文产量😥，于是打算今天写一篇，并说说今日的学习记录吧。\n\n## 学习的一些心得\n\n最近因为Java Web中要使用Java而又对Java不太熟悉的我，翻出了以前库存的一大批书中，写给Java新人的书\n\n《Head First Java》顿时有种相见恨晚的感觉，这书有些难度又不失趣味的介绍了Java的核心思想和技术，对于我这种要巩固Java应用与提高使用水平的我来说，如一盏明灯，在Java的世界中给我照亮了一片前进与深入的方向，请允许我这这里用这种修饰来表达我对这本书的赞誉，虽然这和我以前的博文风格有着极大的不同😅，但是我相信读者朋友（如果有的话）一定可以感受出这本书，或者说这一系列书对我的帮助（下面会说Head First一系列的书），在此，我真的给每一位在自我感觉在入门到中高级的朋友推荐Head First系列的书。","categories":["清单"]},{"title":"博客的一键部署","url":"/2017/11/27/博客的一键部署/","content":"\n# 博客的一键部署\n\n终于在一番折腾和学习下，我用“三脚猫”的水平写了一个能一键写博客的脚本😂，这样以后写博客我只需要想写什么东西了，不用再在部署上折腾了。。。\n\n## 为什么要折腾\n\n说来这么折腾的写博客，也是我自找没趣。。。承接[《博客的备份》](https://blog.dccif.top/2017/10/23/%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD-Git%E5%B0%8F%E6%8A%80%E5%B7%A7/)，我这的写作环境我备份了好多份，每次要在这么多环境之间选择那些可见，那些不可见太麻烦了。。。写脚本的目的也是为了这个，当然脚本我是存在私有仓库的😋~~(写得太烂不好意放出来丢人现眼)~~\n\n","tags":["环境搭建"],"categories":["编程"]},{"title":"数组扩展的效率","url":"/2017/11/04/数组扩展的效率/","content":"\n# 数组扩展的效率差异\n\n说来惭愧，我现在才开始认真的学习算法和程序的效率😓。\n\n本文是我在阅读\n\n> **Data Structures,Algorithms,and Applications in C++** Second Edition\n> *Sartaj Sahni*\n\n遇到的一个小细节，与数组扩展的效率差异的原理。\n\n<!--more-->\n\n# 原始代码\n\n```c++\ntemplate<class T>\nvoid arrayList<T>::insert(int theIndex, const T& theElement)\n{// Insert theElement so that its index is theIndex.\n   if (theIndex < 0 || theIndex > listSize)\n   {// invalid index\n      ostringstream s;\n      s << \"index = \" << theIndex << \" size = \" << listSize;\n      throw illegalIndex(s.str());\n   }\n\n   // valid index, make sure we have space\n   if (listSize == arrayLength)\n      {// no space, double capacity\n         changeLength1D(element, arrayLength, 2 * arrayLength);\n         arrayLength *= 2;\n      }\n\n   // shift elements right one position\n   copy_backward(element + theIndex, element + listSize,\n                 element + listSize + 1);\n\n   element[theIndex] = theElement;\n\n   listSize++;\n}\n```\n\n不知道各位有没有觉得奇怪，为什么**12-16**行是当空间不足的时候，数组空间翻倍呢？\n\n同样的问题书上也提供了解答。。。。不过也许是我数学基础太差了，一时半会没理解😥\n\n本文也参考了*Stack Overflow*上的[Efficiency of growing a dynamic array by a fixed constant each time?](https://stackoverflow.com/questions/19146037/efficiency-of-growing-a-dynamic-array-by-a-fixed-constant-each-time)\n\n## 背后原理\n\n这就要用的数学知识了\n\n让我们假设现在有一个初始长度为1的空数组，需要执行 $n=2^k+1$\n\nn次的插入操作，每次都在尾部插入。\n\n于是，每次插入我们都不需要移动已经存在的元素，n次插入的时间是Θ(n)加上数组扩展长度的时间。\n\n### 数组每次增加1的情况\n\n如果数组每次增加1，那么增加数组长度的时间为\n$$\\Theta (\\sum _{i=1}^{n-1} i)=\\Theta(1+2+3+4+...+(n-1))=\\Theta(\\frac{n(n-1)}{2} )=\\Theta(n^2)$$\n\n利用等差数列的公式，得到，如果数组每次长度增加1，n次插入的总时间是Θ(n^2)。\n\n### 数组每次翻倍的情况\n\n下面来解释为什么原始代码中的数组扩展使用的翻倍\n\n如果数组长度每次增倍，那么改变数组长度的时间是\n\n$$\\Theta(\\sum _{i=0}^k 2^i)=\\Theta(2^0+2^1+2^2+...+2^k)=\\Theta(2^{k+1}-1)$$\n\n$$k={\\log _2(n-1)}$$\n\n$$\\Theta(2^{k+1}-1)=\\Theta(2^{\\log _2(n-1)+1}-1)=\\Theta(2n-3)=\\Theta(n)$$\n\n利用等比数列公式，得到，如果每次数组长度翻倍，n次插入的总时间是Θ(n)。\n\n### 推论\n\n从数组每次翻倍的情况的公式，我们可以看出如果我们总是在原数组上按一个乘法因子来倍增，得到的总时间都是是Θ(n)\n\n这也是为什么[原始代码](#原始代码)中使用的是把长度翻倍的原因。\n","tags":["细节"],"categories":["算法"]},{"title":"Ubuntu的个性化配置","url":"/2017/10/27/Ubuntu的个性化配置/","content":"\n# Ubuntu下的个性化配置\n\n因为使用Linux开发方便的缘故，我在虚拟机上用全性能搭建了一个Ubuntu环境~~(别问我为什么不装双系统)~~\n\n于是和之前那篇Windows的重装一样，也想写一篇文章记录一下，以后搭建时可以方便一些\n\n<!--more-->\n\n## Java环境\n\n本文参考[How To Install Java with Apt-Get on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-ubuntu-16-04)\n\n这里是Java8\n\n添加Oracle's PPA\n\n```shell\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\n```\n\nThen, depending on the version you want to install, execute one of the following commands:\n\n### Oracle JDK 8\n\n```shell\nsudo apt-get install oracle-java8-installer\n```\n\n### Linux下的添加Java环境变量\n\nMany programs, such as Java servers, use the `JAVA_HOME` environment variable to determine the Java installation location. To set this environment variable, we will first need to find out where Java is installed. You can do this by executing the same command as in the previous section:\n\n```shell\nsudo update-alternatives --config java\n```\n\nCopy the path from your preferred installation and then open `/etc/environment` using `nano` or your favorite text editor.\n\n```shell\nsudo nano /etc/environment\n```\n\nAt the end of this file, add the following line, making sure to replace the highlighted path with your own copied path.\n\n/etc/environment\n\n```shell\nJAVA_HOME=\"/usr/lib/jvm/java-8-oracle\"\n```\n\nSave and exit the file, and reload it.\n\n```shell\nsource /etc/environment\n```\n\nYou can now test whether the environment variable has been set by executing the following command:\n\n```\necho $JAVA_HOME\n```\n\n\n\n## 开发环境\n\nVim-gtk 官方源已经有最新的了，直接apt install 就行了\n\nEmacs (需要手动添加源)\n\n```shell\nsudo add-apt-repository ppa:kelleyk/emacs\nsudo apt update\nsudo apt install emacs25\n```\n\n其余jetbrains全家桶，因为没有VS只好用Clion了\n\n\n\n## oh-my-zsh配置zsh\n\nubuntu默认不是zsh，输入下面命令安装 zsh\n\n```shell\nsudo apt-get install zsh\n```\n\n接下来我们需要下载 oh-my-zsh 项目来帮我们配置 zsh，注意此时一定要用 超级权限。\n\n```shell\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n\n查看你的zsh位置，输入\n\n```shell\ncat /etc/shells\n```\n\n```shell\n➜  ~ cat /etc/shells\n# /etc/shells: valid login shells\n/bin/sh\n/bin/dash\n/bin/bash\n/bin/rbash\n/bin/zsh\n/usr/bin/zsh\n➜  ~ \n```\n\n更改默认 shell，输入\n\n```shell\nsudo vim /etc/passwd\n```\n\n更改 root 和用户默认 shell\n\n```shell\nroot:x:0:0:root:/root:/usr/bin/zsh\nsong:x:1000:1000:song,,,:/home/song:/usr/bin/zsh\n```\n\nzsh 的配置文件是在用户目录下的 .zshrc\n\n每一行的配置前面都有#号,如果想要配置生效,去掉 #号即可.\n\n## 补全插件 incr.zsh\n\n这个插件的官网是: [Incremental completion on zsh](http://link.zhihu.com/?target=http%3A//mimosa-pudica.net/zsh-incremental.html)\n\n最新版本是 incr-0.2.zsh \n\n新建一个 incr-0.2.zsh 文件把他放进 用户目录下的 .oh-my-zsh/plugins/incr 目录下，没有的目录自己新建，其实放哪都一样。\n\n分别编辑 root 目录下的 .zshrc 和用户目录下的 .zsnrc\n\n加上一句\n\n```shell\nsource /home/song/.oh-my-zsh/plugins/incr/incr-0.2.zsh\n```\n\n/home/song/.oh-my-zsh/plugins/incr 是你放的不同的目录。\n\n最后还有一个小问题，原来我们用的 超级用户创建的 oh-my-zsh 导致 .oh-my-zsh 目录下的缓存目录 cache 所有者和用户组也是root 这样就导致我们在普通用户下使用有些问题，下面改变 cache的所有者\n\n输入\n\n```shell\nchown song:song cache/ -R\n```\n\n这样就不会在命令提示时候弹出错误了。\n\n","tags":["环境搭建"],"categories":["清单"]},{"title":"博客备份-Git小技巧","url":"/2017/10/23/博客备份-Git小技巧/","content":"\n# Hexo博客的备份\n\n可能是因为被害妄想症的原因吧，我怕博客的丢失，在我的硬盘，电脑和GitHub和私有服务器上备份了四份，在本博客的仓库的Public分支上就是我的博客文章的备份\n\n<!--more-->\n\n## 为什么要备份\n\n备份的重要性我觉的不用我说了吧，为了防止数据的丢失 ~~虽然好像没什么宝贵的数据~~\n\n其实是突然发奇想想利用Git的分支来在一个仓库管理我的博客\n\n## 为什么只备份文章\n\n毕竟文章本来就是给各位看的，但是私人的配置文件中有个人APIKey和一些个性化设定，这些可不好Public了😃\n\n## Git小技巧\n\n因为这次忽略文件是我临时添加的，再修改了**.gitignore**文件后在次上传并没有生效\n\n感谢pfeng的作者，本文参考 http://www.pfeng.org/archives/840\n\n在**git**中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 **.gitignore** 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：\n\n\n```shell\n# 此为注释 – 将被 Git 忽略\n*.a         # 忽略所有 .a 结尾的文件\n!lib.a      # 但 lib.a 除外\n/TODO`      # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/      # 忽略 build/ 目录下的所有文件\ndoc/*.txt   # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n```\n规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是**.gitignore**只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改**.gitignore**是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：\n```shell\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```","tags":["细节"],"categories":["编程"]},{"title":"重装系统程序清单","url":"/2017/10/16/重装系统程序清单/","content":"# 因为种种原因\n我不得不重装我这用了快3年的电脑，心里一阵苦，本清单用于个人重装系统后的恢复工作，日后也能参考\n\n\n\n# 驱动安装\n~~这步我就不说了~~\n\n这个周末被这个折腾的够呛，我觉得还是有必要说一下了😭\n\n<!--more-->\n\n首先说下我遇到的坑吧，现在事后说起来觉得好蠢，可以当我遇到的时候真是百思不得其解。\n\n这次我遇到的坑一句话就是驱动的冲突，我原本的罗技鼠标和这个国产软件----驱动精灵，检测出来的不一样，于是就给我装了一个雷蛇的驱动。。。关键是我装好了之后还没法卸载。导致的现象就是每次开机我都要手动用管理员权限打开罗技的`游戏软件`，也许是我强迫症吧，为了发现和解决这个问题，我重装了5次系统。。。\n\n\n\n好好的一个周末都被浪费掉了。。。\n\n收获就是国产的驱动软件不能完全相信。。，每一步安装前要先确认一下这个驱动是什么\n\n还有2个被土啬的驱动检测软件，这两个的驱动都是没有问题的，名字我就先不提了。\n\n## 程序清单\n没有链接的文件在个人备份的磁盘中\n### 语言环境\n1. [Java8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n2. [Tomcat9](https://tomcat.apache.org/download-90.cgi)\n3. [Python](https://www.python.org/downloads/)\n4. [Node.js](https://nodejs.org/en/)\n5. **别忘了配置环境变量**\n\n### 开发工具\n#### 微软\n1. [Visual Studio](https://www.visualstudio.com/zh-hans/) (~~之所以重装都是因为这个巨无霸~~)\n2. [VIsual Studio Code](https://www.visualstudio.com/zh-hans/) (还好没有什么配置文件)\n#### GNU\n3. [Emacs](http://mirrors.ustc.edu.cn/gnu/emacs/windows/)，GVIM (硬盘中拷备份件)\n4. [Git](https://git-scm.com/download/win)\n5. [GitHub Desktop](https://desktop.github.com/)\n#### JetBrains\n4. [Intellij IDEA](https://www.jetbrains.com/idea/)\n5. [Android Studio](https://developer.android.com/studio/index.html)\n6. [WebStorm](https://www.jetbrains.com/webstorm/?fromMenu)\n7. [PyCharm](https://www.jetbrains.com/pycharm/?fromMenu)\n#### 其他\n8. [Eclipse](http://www.eclipse.org/home/index.php)\n9. [DrRacket](https://racket-lang.org/download/)\n10. VMware Workstation Pro\n11. [wampserver](http://www.wampserver.com/en/)\n12. [Wireshark](https://www.wireshark.org/download.html)\n13. [Notepad++](https://notepad-plus-plus.org/download/v7.5.1.html)\n\n### 多媒体\n1. [Potplayer](https://potplayer.daum.net/)\n2. PDFX\n3. [foobar2000](http://blog.sina.com.cn/s/blog_6fcc51420102wv92.html)\n4. [Calibre](https://calibre-ebook.com/download)\n5. Sigil\n6. [Mp3tag](https://www.mp3tag.de/en/download.html)\n\n### 娱乐\n1. [Steam](http://store.steampowered.com/about/)\n\n### 学习\n1. GoldenDict\n2. wolfram mathematica\n3. [ManicTime](https://www.manictime.com/)\n\n### 效率工具\n1. [Everything](https://www.voidtools.com/downloads/)\n2. IDM\n3. [f.lux](https://justgetflux.com/)\n4. [Ditto](http://ditto-cp.sourceforge.net/)\n5. [Dism++](https://www.chuyu.me/zh-Hans/)\n6. [TeamViewer](https://www.teamviewer.com/zhcn/download/windows/)\n7. [Sumo](https://www.kcsoftwares.com/?download)\n8. [Wox](https://github.com/Wox-launcher/Wox/releases)\n9. TriDnet\n10. XYplorer\n11. Total Commander\n12. MySpeed\n13. [Listary](http://www.listary.com/download)\n14. [Input Director](https://www.inputdirector.com/downloads.html)\n15. Capture2Tex\n16. Process\n\n### SSH工具\n1. XX-net\n2. [Proxifier](https://www.echoteen.com/proxifier-newway.html)\n3. Xshell5 & Xftp\n4. [FileZilla](https://filezilla-project.org/)\n\n### 浏览器及插件\n1. [Chrome32bit](https://www.google.com/chrome/browser/desktop/index.html)\n  备份文件\n2. [Firefox](https://www.mozilla.org/zh-CN/firefox/desktop/)\n\n## 其余\n在个人备份硬盘中","tags":["环境搭建"],"categories":["清单"]},{"title":"IDEA下的Java Webapp环境搭建","url":"/2017/10/14/IDEA下的Java-Webapp环境搭建/","content":"# IDEA 下Java Webapp的环境搭建\n\n本文在以下环境搭建：\n> IntelliJ IDEA 2017.2.5\n> JDK 1.8.0_144\n> JRE: 1.8.0_152-release-915-b12 amd64\n> JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o\n> Apache Tomcat 9.0.1 Server\n> Windows 10 x64 15063.674\n\n**注意!!** 本文不包括JAVA环境及Tomcat的搭建！\n\n<!--more-->\n\n## 写文缘由\n\n可能有人问我既然不是写给新人看的，还不写重点的JAVA环境及Tomcat的搭建，你写这有什么用？那么你可以**Ctrl+w**了。因为现在网上的都是关于Eclipse或者老版本的IDEA的教程，所以想写一篇新的，顺带拉一波新人入IDEA的坑。\n\n~~个人不喜欢课堂上老师用的旧工具~~\n\n### 新建Project\n{% img /image/IDEA/newproject.jpg 新建项目 %}\n\n{% img /image/IDEA/select.jpg 选择应用module %}\n\n下一步随便给项目取一个名字\n\n### **下面是重点了**\n可能是我的环境太新了，和网上的教程生成的目录结构是不一样的。\n\n{% img /image/IDEA/struct.jpg 目录结构 %}\n\n我们要新建2个文件夹，都是在web/WEB-INF/目录下\n\n1. classes {% raw %}&nbsp&nbsp&nbsp&nbsp{% endraw %} --编译后的文件\n2. lib {% raw %}&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp{% endraw %} --以后要引入的库\n\n### 新的目录结构 {% img /image/IDEA/after.jpg 新建Servlet和新的目录结构 %}\n\n{% img /image/IDEA/newservlet.jpg 新建Servlet %}\n\n### 更改项目目录结构 {% img /image/IDEA/newstruct.jpg 更改目录结构 %}\n\n#### 更改out目录 {% img /image/IDEA/newout.jpg 更改out目录 %}\n\n#### 更改lib目录 {% img /image/IDEA/newlib.jpg 更改lib目录 %}\n\n#### 更改out结构 {% img /image/IDEA/outset.jpg 更改out结构 %}\n\n### 配置服务器 {% img /image/IDEA/configserver.jpg 配置服务器 %}\n\n{% img /image/IDEA/setserver1.jpg %}\n\n{% img /image/IDEA/setserver2.jpg 配置服务器 %}\n\n## 测试代码\n\nJsp 测试：\n\n```Jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>简单的JSP页面</title>\n</head>\n<body>\n<h1>Hello,World!</h1>\n现在的时间是: <%= new java.util.Date() %>\n</body>\n</html>\n```\n结果：\n\n{% img /image/IDEA/result1.jpg Jsp页面测试 %}\n\n\n\nServlet 测试：\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@WebServlet(name = \"HelloServlet\", urlPatterns = {\"/helloServlet.do\"})\npublic class HelloServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html>\");\n        out.println(\"<head><title>当前时间</title></head><body>\");\n        out.println(\"<h3>Hello,World!</h3>\");\n        out.println(\"现在时间是：\" + new java.util.Date());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n```\n\n结果：\n{% img /image/IDEA/result2.jpg Servlet测试 %}\n\n## 搭建完成\n至此完成了在IDEA上Servlet的环境搭建。\n\n~~你以为接这样结束了？~~\n\n你难道想每次都按怎么多才能搭建好环境？\n~~其实可以选择Maven的，但是Maven更难掌握~~\n有个简单的方法能节省几步以后搭建的操作\n\n### 保存模版\n\n{% img /image/IDEA/savetemp.jpg 保存模版 %}\n\n之后就能看到了\n\n{% img /image/IDEA/usertemp.jpg 用户模版 %}\n\n然而这个功能支持Java项目并不完美，所以以后每次都要新建两个文件夹，就是classes和lib，但之后的目录结构设置会自动完成的\n","tags":["环境搭建"],"categories":["编程"]},{"title":"Prologue","url":"/2017/10/10/Prologue/","content":"# 一些闲话来作为我博客的序章吧\n\n可以说是“**机缘巧合**”吧，我从原来的自建服务器迁移到了[**GitHub Pages**](https://pages.github.com/)上，具体的原因我绝的可以留到下一篇博文再说了😜\n\n## 写作的缘由\n\n在一番折腾之后终于搭成了这个博客，想着也不能浪费，于是就来写写东西了，主要也是个人生活或者学习的记录。不过鉴于我个人的水平，如果有读者有幸看到这篇文章的话，那么也请别抱太大的希望，因为我本质上还是一个`理工男`。在本博客中你可能看不到什么精彩的文风或者犀利的批判。\n\n<!--more-->\n\n## 本博客以后和现在的内容\n\n想了半天也不知道和清楚写什么，于是就想先介绍一下博客好了。\n\n以后包括未来博主主要写的文章大多是\n\n1. 编程类\n2. 细节类\n3. 感想类\n4. 推荐类\n\n下面就来细说一下好了。~~我又想到扯得东西了~~\n\n### 编程类\n\n因为本人专业和兴趣的原因，我还是写的编程的多点，因为这个博客我也想当成我学习编程的成长记录吧。\n\n### 细节类\n\n怎么定义呢？说实话我也很难说什么属于细节，只是因为以前写的文章算是细节，便单独开了一个目录了，因为我现在的编程学习，个人还是理论派，看的书比写的码多，于是便把一些书上好的地方记录下来，日后也许可以写一些物品在实践中处理问题遇到的细节。\n\n### 感想类\n\n虽然我现在一篇此类的文章都没写，但是我觉得一个博客之所以能叫博客就是因为能抒发作者自己的想法，所以我的博客也不例外，如果没有这个类的话，我的博客就不能说是我的博客了，只能说是一些零散知识的拼凑。\n\n### 推荐类\n\n个人觉得这也许是我以后写的最多的文章了，因为个人对新奇软件和数码的喜好，我个人会推荐和介绍一些本人正在使用的好的软件或硬件，甚至是上文编程类中的好东西，当然这也是否考验功力，你凭什么推荐这个？","tags":["闲谈"],"categories":["随想"]},{"title":"递归的两种优化方法","url":"/2017/10/10/递归的两种优化方法/","content":"# 递归（Recursion）的两种优化方法\n\n最近学习了一些递归的优化方法，于是想写一篇文章记录一下，方便以后查看，并想分享一下。\n虽然平日的上课中老师都是建议我们不要使用递归，但是在**函数式编程（functional programming）**中递归是很常用的，而且掌握递归的思想有时能让我们找到最优解。\n\n<!--more-->\n\n## 1. 最经典的斐波那契数列\n\n```c\nint Fibonacci(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    else\n    {\n        return Fibonacci(n - 2) + Fibonacci(n - 1);\n    }\n}\n```\n\n这个算法一般计算到40左右就不行了，因为运行栈已经被函数的递归调用占满了\n\n## 2. 尾递归（Tail Recursive）\n\n传说中的[**尾递归**](https://www.wikiwand.com/zh/%E5%B0%BE%E8%B0%83%E7%94%A8)。具体我不细说了，就是上一个版本的优化，每次调用函数时不生成新的运行栈，利用上一次的结果\n**注意：**不是所有语言都有**尾递归**优化的（Java就没有）\n       也不是所有算法都能写成**尾递归**的形式的\n\n``` c\nint fiboTail(int n, int acc, int cal) \n//acc充当收集器的左右，收集上一次运行栈的返回值，因为之后栈空间会被回收\n//cal是每一次递归的计算\n{\n    if (n == 1) return acc;\n    if (n == 2) return cal;\n    return fiboTail(n - 1, cal, acc+cal);\n}\n```\n\n可以看到尾递归的函数比原始的版本多了2个参数，一个起到**收集器（accumulator)**的作用，记录每上一次栈的返回值，因为原来栈的空间会被下一层递归覆盖。\n还有一个参数就是每次递归的操作了，因为是斐波那契，所以这里是相加。\n\n尾递归的调用方法也与原来的不一样，因为斐波那契的初始值 ( 1. 1 . 2 . 3 ......)\n所以以下的调用，acc 要用初始值 1，cal 也要用第二位的值这里也是1\n调用的方法就是  **fiboTail(n, 1，1）**\n尾递归的方法计算基本上是秒出的，可是比起下面一种方法还是要慢，就是在32位机器上要注意 **int范围** 第47位已经超过int的表示范围了\n\n## 3. 利用缓存\n\n典型的空间换时间\n\n``` c\nenum { gnFib = 99 };\nint gFib[gnFib];      // 生成一个数组记录已经生成的斐波那契数\n\nint fib(int n)\n{\n    if (n < 0 || n >= gnFib) return 0;\n    int &fn = gFib[n];   \n    if (!fn) {            //如果当前数不在数组中才计算\n        if (n == 0 || n == 1) fn = 1;\n            else fn = fib(n - 1) + fib(n - 2);\n    }\n    return fn;\n}\n```\n\n核心思想就是利用之前信息，每次递归不用再重新计算了\n","tags":["优化"],"categories":["编程"]},{"title":"短路求值(Short-circuit evaluation)","url":"/2017/10/10/短路求值-Short-circuit-evaluation/","content":"# 短路求值\n\n> Short-circuit evaluation\n\n最早是在**php**中接触到的这种求值，后来在学习**Lisp**中又一次接触到了，于是想写一篇文章记录一下，并分享一下，这个被我忽略的可能可以说是细节的点吧\n\n<!--more-->\n\n## 什么是**短路求值（Short-circuit evaluation）**\n\n以下摘自[Short-circuit evaluation](https://www.wikiwand.com/en/Short-circuit_evaluation)\n> **Short-circuit evaluation**, minimal evaluation, or McCarthy evaluation (after John McCarthy) is the semantics of some Boolean operators in some programming languages in which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression: when the first argument of the AND function evaluates to false, the overall value must be false; and when the first argument of the OR function \nevaluates to true, the overall value must be true.\n\n概况来说就是在求**布尔表达式**的时候程序并不会执行全部的**Expression**\n\n比如**AND**或者**OR**操作时如果后面第一个Expression为True，那么之后的Expression就不会再求值了。\n\n## 一些例子\n\n### 普通的**C**程序\n\n```c\nint denom = 0;\nif (denom != 0 && num / denom)\n{\n    ... // ensures that calculating num/denom never results in divide-by-zero error   \n}\n```\n\n### 使用了短路求值的**C**程序\n\n```c\nint a = 0;\nif (a != 0 && myfunc(b))\n{\n    do_something();\n}\n```\n\n在这个例子中**&&**后的**myfunc(b)**将永远不会执行，因为**a!=0**永远是**FALSE**。\n利用短路求值有2个有用的技巧\n\n 1. 如果条件判断的expression需要复杂的计算，并且第一个结果为**False**，则可以不计算之后的表达式\n 1. 可以构造一个expression来使第二个可能会发生运行时错误的expression成功运行\n\n```c\nbool is_first_char_valid_alpha_unsafe(const char *p)\n{\n    return isalpha(p[0]); // SEGFAULT highly possible with p == NULL\n}\n\nbool is_first_char_valid_alpha(const char *p)\n{\n    return p != NULL && isalpha(p[0]); // 1) no unneeded isalpha() execution with p == NULL, 2) no SEGFAULT risk\n}\n```\n\n这个例子避免了空指针\n\n### 最近学习的Lisp中的例子：\n\n```Lisp\n(defparameter *is-it-even* nil)\n(or (oddp 5) \n(setf *is-it-even* t))\n```\n\n利用短路求值，用**OR**实现了条件判断\n\n## 可能的问题：\n\n尽管有上面说的优点，但是可能会带来没有意识到的问题，比如：\n\n```c\nif (expressionA && myfunc(b)) {\n    do_something();\n}\n```\n\n当**expressionA**为**True**时无论**do_something()**是否执行，**myfunc(b)**都会执行，例如分配系统资源的操作。\n\n相反，**expressionA**为**False**时**myfunc(b)**永远不会执行\n\n## 支持的语言\n\n**并不是所有语言和所有操作符支持的**\nJava支持**非短路求值**也支持**短路求值**\n\n| 常见的语言 | 支持的操作符 |\n| :------- | :--------- |\n| C, Obejective-C, C++, C# | &&, ∥, ? |\n| Java, MATLAB, R, Swift | &&, ∥ |\n| JavaScript, GO, Haskel | &&, ∥ |\n| Lisp, Lua, Scheme | and, or |\n| PHP | &&, and, ∥, or |\n| Python | and, or |\n| Visual Basic | 不支持 |","tags":["细节"],"categories":["编程"]},{"title":"my test page","url":"/2017/10/10/my-test-page/","content":"# 个人测试页\n\n## 这是我的一个测试页面\n\n### 我也不知道写什么好\n"},{"title":"一个简单的简谱转调程序","url":"/2017/08/07/一个简单的简谱转调程序/","content":"\n# 老版本的问题\n\n从[《记第一个对我有实际作用的程序》](https://blog.dccif.top/2015/12/14/%E8%AE%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AF%B9%E6%88%91%E6%9C%89%E5%AE%9E%E9%99%85%E4%BD%9C%E7%94%A8%E7%9A%84%E7%A8%8B%E5%BA%8F%EF%BC%88%E9%80%83%EF%BC%89/)之后已经过了602天。终于我更新了第二个版本😂\n\n尴尬.......其实我也只是为了练习前几天新学的新方法（不然谁还挖以前的坑）🤣\n\n回想我上一个版本的程序，只能转换**全音**，还没法识别**半音**。。。。现在来看就是因为那时我用了**键值对**的方法来转换的。。。我没功夫把所有的音阶都记录下键值对。。。\n\n同时感谢贴吧  [DverysGetime](https://tieba.baidu.com/home/main?id=tb.1.8026e840.pvGEopbxnwZpX2aH7NkVfg) 的贴，让我理解的转调原理，原文 [【申精】DG教你看简谱音阶转调图，转调翻译再也不求人](https://tieba.baidu.com/p/2473627200)\n\n我的**参照表**也是原贴中的：\n\n![jp1](/image/tuneChange/jp1.webp)\n\n这样一看下来\n\n如果全部写成键值对的话就要\n\n$12*3*12=432$\n\n一共这么多对，当然理论上也不是不行，但是当写成这么傻的方法时，应该要考虑换一下方法了。。。。\n\n<!--more--> \n\n各位这时不妨也思考一下怎么转换好了，这篇文章我是不会贴代码了（反正我知道也没人会看）我只分享我的思路\n\n# 新思路\n怎么样，思考好了吗？（多半也没人认真想吧!😝)\n\n那么我分享一下我的思路\n\n首先原来的音阶表上的音名。。。ABC 这些对我干扰太大了😥，[老的版本](https://github.com/dccif-zz/Bauble/blob/master/TuneChange/TuneChange.py)上我就傻傻地把简谱的1,2,3还先转换成音名CDE\n\n然后利用CDE在我提前输入的转换表中查找来进行音调转换\n\n因为原来我天真地认为是\n\n不管输入什么简谱的1，2，3对应到表上第一排的音名是不变的，再利用音名转换到目标简谱上就行了。。。\n\n看过我[原先的程序](https://github.com/dccif-zz/Bauble/blob/master/TuneChange/TuneChange.py)的就知道了，很傻很天真的方法表情\n\n所以我就参考了**转调的定义**：不同调的**Do位置**不同，在上面的图上中间灰色的矩形很好的表示了这一点，也就是说不同的调的转换只需要移动**Do的位置**就行了，并不用原先的我用的那种还需要音名CDE来当两个不同简谱间桥梁的转换方法。\n\n那么发现了转调的定义后，如何实现的这个所谓的“**移动的Do的位置**”呢？\n\n用户的输入都是各自调的1,2,3,4...... 程序要做的是移动他们输入调的Do到目标调上。\n\n## 换一个角度看问题\n\n![jp2](/image/tuneChange/jp2.webp)\n\n怎么样？有答案了吗？这样建立坐标后，就不用管什么音调，音名了，要做的只有坐标之间的转换。\n\n![jp3](/image/tuneChange/jp3.webp)\n\n是不是一下觉得很简单了？\n\n要做的就是把输入转换成一个坐标，然后再转到目标调所在的坐标就行了。这样就能实现“**移动D的位置**”\n\n根本不用考虑如何把1,2,3与C D E 对上，我们要考虑的问题又从“**移动D的位置**”变成了如何获取输入的“**坐标**”位置。\n\n再仔细看这个2位**坐标**的转换问题；我原先旧的程序就是已知一个调转换到另一个调，也就是在上图的两行之间转换，\n\n提前选择的要转换的调就是告诉我们初始**X坐标**了，要转换的目标调也就是告诉我们另一个点的**X**值了\n\n也就是程序提前就能知道两个**坐标（X,Y）**中的**X**值，实际上的计算只要在**Y**上计算不同行之间的差了。也就是说这样就实现了“**移动Do的位置**”\n\n## 怎么样，思路有了，剩下就是实现了吧！\n\n既然我已经写了这篇文章\n\n就是我个人已经实现了😀\n\n上次我的做的是（没人会再用的）命令行程序\n\n这次我打包成exe文件了，顺带还做了图形界面，毕竟隔了那么久了（这602天不能白过啊）\n\n如果还是做是命令行，再做一次就没什么意思了\n\n[程序地址](https://github.com/dccif-zz/TuneChange/releases)\n\nVersion 0.1\n\n个人画的GUI，有点丑，这就不要在意了\n\n![jp4](/image/tuneChange/jp4.webp)\n\n简单明了(一堆Bug)\n\n![jp5](/image/tuneChange/jp5.webp)\n\n现在的版本也就是简单的“**坐标转换**”，输入格式不对的话就不能转换了\n\n这次的版本使用因为使用了上面说的方法，核心的“**坐标转换**”就用了一个**键值对**表和4行代码就实现了，当然这是Python的版本。。。。用其他麻烦一点的语言可能就不止了。\n \n后续会不会再升级或者修Bug什么的（多半是不可能了，看看和上次隔了多久），倒是我可能会顺带尝试一下Android端，因为做以上这个程序只是顺带的\n\n实际是练习前面文章第二行说的新方法：一种和**面向对象编程**（OOP）不同但是又同样强大的方法——**函数式编程**\n\n[项目地址](https://github.com/dccif-zz/TuneChange)","tags":["编程","音乐"],"categories":["编程"]},{"title":"记第一个对我有实际作用的程序（逃）","url":"/2015/12/14/记第一个对我有实际作用的程序（逃）/","content":"\n# 问题的起因（挖坑原因）：\n\n1. 玩乐器的同学知道，简谱上的不同调之间的转换不如五线谱上方便，我原来最先是参照转调表一个一个人工查找😥太累，后来就想写个程序完成了。\n2. ———关于调，不懂的可以百毒一下。。。就是与起始音do的位置，或者末音la的位置（这不是小调了吗，不管，乐理也不太精通，如有大神求指出） \n\n# 问题的实现：\n\n1. 脑洞昨天太大😓，明明只是一个会C调的，你干嘛要写个转换任意调的。。。。\n    原始目的只是想任意调转成C，后来写着写着觉得这样这程序太弱了（虽然本来就不强)，就临时想转成任意调了。。。。于是有琢磨了一会就有了实现。。。\n  \n2. 实现思路：当初第一目的——任意调到C，最初是想通过if一句一句判断进行实现。。。。后来想写任意调后发现不现实，因为会有C(6,2)，15种可能，每个if下还要再进行判断是否是1，2，3，4，这类的简谱名，这样会造成程序的冗长与无用。。。于是就放弃了\n\n3. 于是想到了Python的dict数据结构，使用key-value对，便可以便捷的实现调之间转换，只需提前输入好dict\n\n<!--more-->\n\n# 实现过程中的问题：\n1. 我就不应该用command line（命令行）来获取输入数据🙈\n\n2. 命令行输入的数据我要考虑各种间隔，因为input()函数获取的输入是“******“中的所有字符，其中考虑如何实现区分，b7,7 ，8这类输入都头疼了我好久。。\n\n     b7在input()中会当成b和7两个单独的字符，而我想表示的是低音7，\n     \n     ![cmd](/image/tuneChange/cmd.webp)\n     \n     7，8在input()中也会傻不拉唧的把逗号（，）也识别进入，我要想办法去除符号后才能进行数据操作\n     \n# 问题的解决\n1. input()的问题，假设用户配合，全用空格分开，便可利用.split(\" \")方法进行去除，之后便可传入列表就行操作\n2. 函数中局部变量和函数定义好后，不会自行调用真是够了\n\n# 一些感想\n\n1. 变量名要取好，我这么一点我都有时忘记了这个变量是干嘛（水平太差）\n\n2. 函数中的变量尽量与函数外的变量不要重名，我这个就是重名的，有时搞不懂为何会没有输出，就是因为函数中变量是局部的\n\n3. 写什么要先写好第一目的，不要想我这样，写着写着又想写其他目的了，也不要想我一样边写边调试，大部分时间都废在找bug和纠错上了。。。。当然因为我是写着写着就想别的目的了，所以边写边调试还是没什么问题的。。。（我觉得）\n\n# 垃圾代码\n\n```python\n#一时兴起想写的转换简谱调的代码，可以实现任意调之间的转换，啪啪啪，如果在字典中\n#有的话。。。字典还没填完备，暂时只有其他调的全音，还无半音\n#因为字典还不完备，任意调之间的转换可能会出问题，转c调是没问题的\n#（啪啪，打脸，@_@，原本只是想任意调转c，后来脑洞又开，写任意调了）\n#命令行版本。。command line version。我觉得还是函数版本好写，不管了以后有空再补\n#输入\nprint(\"Please enter the original an'dand ambition tune(use space splite)\")\ntuneer = input(\"The default is to C:\")\n'''#b表示低音，#表示升（半音阶），g表示高音，用b#表示低半音，用g#表示高半音'''\nputin = input(\"please enter number:\")\nfirst1 = \"\"\nlistin1 = []\nlistin2 = []\nlistout1 = []\nlistout2 = []\nlistoutTemp = []\nlistTemp = []\nchangekey = {}\nchangekey2 = {}\n\n# #如有空格去除后再操作\n# first1 =\"\"\n# listin1 = []\n# listin2 = []\n# listout1 = []\n# first1 = putin.strip()\n# final1 = first1.split(\" \")\n# for i in final1:\n    # listin1.append(i)\n# print(listin1)\n# #对tune去除\n# first2 =\"\"\n# first2 = tuneer.strip()\n# final2 = first2.split(\" \")\n# for i in final2:\n    # listin2.append(i)\n# print(listin2)\n\n#清除空格和转换大小写，默认到c调\ndef checkspace(listin):\n    '''#b表示低音，#表示升（半音阶），g表示高音，用b#表示低半音，用g#表示高半音'''\n    listTemp = \"\"\n    listTemp = listin.strip()\n    listlow = listTemp.lower()\n    listOut = listlow.split(\" \")\n    if len(listOut) == 1:\n        listOut.append(\"c\")\n    return listOut\n    \n#获取原始输入\nlistin1 = checkspace(putin)\nformtuneer = checkspace(tuneer)\ntuneerin = formtuneer[0]\ntuneerout = formtuneer[1]\n\n#b表示低音，#表示升（半音阶），g表示高音，用b#表示低升半音，用g#表示高半音\n    \n#keys   \nGtoC = {\"1\" : \"b5\", \"2\" : \"b6\", \"3\" : \"b7\", \"4\" : \"1\", \"5\" : \"2\", \"6\": \"3\", \n\"7\" : \"#4\", \"g1\" : \"5\", \"g2\":\"6\",\"g3\":\"7\",\"g4\":\"g1\",\"g5\":\"g2\",\"g6\":\"3\",\n\"g7\":\"g#4\",\"gg1\":\"g5\"}\nAtoC = {\"b7\" : \"#5\", \"1\" : \"b6\", \"2\" : \"b7\", \"3\" : \"#1\", \"4\" : \"2\", \"5\" : \"3\",\n\"6\" : \"#4\", \"7\" : \"#5\", \"g1\" : \"6\", \"g2\" : \"7\", \"g3\" : \"g#1\", \"g4\" : \"g2\",\n\"g5\" : \"g3\", \"g6\" : \"g#4\" }\nBtoC = {\"b6\" : \"b#5\", \"b7\":\"b#6\", \"1\" : \"b7\", \"2\" : \"#1\", \"3\" : \"#2\", \"4\" : \"3\",\n\"5\" : \"#4\", \"6\" : \"#5\", \"7\" : \"#6\", \"g1\" : \"7\", \"g2\" : \"g#1\", \"g3\" : \"g#2\",\n\"g4\" : \"g3\", \"g5\" : \"g#4\"}\nDtoC = {\"b4\" : \"b5\", \"b5\" : \"b6\", \"b6\" : \"b7\", \"b7\" : \"#1\", \"1\" : \"2\",\n\"2\" : \"3\", \"3\" : \"#4\", \"4\" : \"5\", \"5\" : \"6\", \"6\" : \"7\", \"7\" : \"g#1\", \n\"g1\" : \"g2\", \"g3\" : \"g#4\", \"g4\" : \"g5\"}\nEtoC = {\"b3\" : \"b#5\", \"b4\" : \"b6\", \"b5\" : \"b7\", \"b6\" : \"#1\", \"b7\" : \"#2\",\n\"1\" : \"3\", \"2\" : \"#4\", \"3\" : \"#5\", \"4\" : \"6\", \"5\" : \"7\", \"6\" : \"g#1\", \n\"7\" : \"g#2\", \"g1\" : \"g3\", \"g2\" : \"g#4\"}\nFtoC = {\"b2\" : \"b5\", \"b3\" : \"b6\", \"b4\" : \"b#6\", \"b5\" : \"1\", \"b6\" : \"2\",\n\"b7\" : \"3\", \"1\" : \"4\", \"2\" : \"5\", \"3\" : \"6\", \"4\" : \"#6\", \"5\" : \"g1\", \"6\" : \"g2\",\n\"7\" : \"g3\", \"g1\" : \"g4\", \"g2\" : \"g5\"}\n\nFulltunekey = {\"g\":GtoC, \"a\" : AtoC, \"b\" : BtoC, \"d\" : DtoC, \n\"e\" : EtoC, \"f\" : FtoC}\n\n#Anykeys，key转换\ndef inverse(dict):\n    dictout = {v : k for k,v in dict.items()}\n    return dictout\n    \nCtoG = inverse(GtoC)\nCtoA = inverse(AtoC)\nCtoB = inverse(BtoC)\nCtoD = inverse(DtoC)\nCtoE = inverse(EtoC)\nCtoF = inverse(FtoC)\n\nFulltuneanykey = {\"g\" : CtoG, \"a\" : CtoA, \"b\" : CtoB, \"d\" : CtoD, \n\"e\" : CtoE, \"f\" : CtoF}\n\n#转换key-values对 （first 全到C)\ndef dictoc(tuneerin,tuneerout):\n    if tuneerin == \"a\":\n        changekey = Fulltunekey[\"a\"]\n    elif tuneerin == \"g\":\n        changekey = Fulltunekey[\"g\"]\n    elif tuneerin == \"b\":\n        changekey = Fulltunekey[\"b\"]\n    elif tuneerin == \"d\":\n        changekey = Fulltunekey[\"d\"]\n    elif tuneerin == \"e\":\n        changekey = Fulltunekey[\"e\"]\n    elif tuneerin == \"f\":\n        changekey = Fulltunekey[\"f\"]\n    return changekey\n# def dicany(tuneerin,tuneerout):\n    # if tuneerin != \"c\":\n        # changekey = Fulltunekey[tuneerin]\n        \n#判断输出，如不是C，再进行转换\ndef dictoany(tuneerout):\n    if tuneerout == \"a\":\n        changekey2 = Fulltuneanykey[\"a\"]\n    elif tuneerout == \"g\":\n        changekey2 = Fulltuneanykey[\"g\"]\n    elif tuneerout == \"b\":\n        changekey2 = Fulltuneanykey[\"b\"]\n    elif tuneerout == \"d\":\n        changekey2 = Fulltuneanykey[\"d\"]\n    elif tuneerout == \"e\":\n        changekey2 = Fulltuneanykey[\"e\"]\n    elif tuneerout == \"f\":\n        changekey2 = Fulltuneanykey[\"f\"]\n    return changekey2   \n    \n#强制全部到c调\ndef alltoC(tuneerin):\n    changekey = dictoc(tuneerin, tuneerout)\n    for i in listin1:\n        listout1.append(changekey[i])\n    #print(listout1)\n    return listout1\n    \n\n# print(listout1)\ndef ctoall(tuneerout):\n    if tuneerout != \"c\":\n        changekey2 = dictoany(tuneerout)\n        listout1 = alltoC(tuneerin) \n        for i in listout1:\n            listout2.append(changekey2[i])\n    return listout2\n# ctoall(tuneerout)\n# print(listout2)   \n    \n# if tuneerout != \"c\":\n    # dicany(tuneerout)\n    # for i in listoutTemp:\n        # listout1.append(changekey[i])\n    # print(listout1)\n    \n\n#最后输出   \ndef checkout(tuneerin,tuneerout):\n    if tuneerout == \"c\":\n        alltoC(tuneerin)\n        print(tuneerin,listin1)\n        print(\"->\")\n        print(\"c\",listout1) \n    else:\n        listout2 = ctoall(tuneerout)\n        print(tuneerin,listin1)\n        print(\"->\")\n        print(tuneerout,listout2)\n    return\n\ncheckout(tuneerin,tuneerout)\n\n\n#AtoC = {\"b7\" : \"#5\", \"1\" : \"b6\", \"2\" : \"b7\", \"3\" : \"#1\", \"4\" : \"2\", \n\"5\" : \"3\", \"6\" : \"#4\", \"7\" : \"#5\", \"g1\" : \"6\", \"g2\" : \"7\", \"g3\" : \"g#1\", \n\"g4\" : \"g2\", \"g5\" : \"g3\", \"g6\" : \"g#4\" }\n# if tuneerout == \"c\":\n    # for i in listin1:\n        # listout1.append(changekey[i])\n    # print(listout1)\n```\n\n如有大神愿意改良或者提出修改的话。。。求到 [Github地址](https://github.com/dccif-zz/Bauble/blob/master/TuneChange/TuneChange.py)\n\n感激不尽。。。。（半路出家，最近更快期末了，压力山大 ）","tags":["编程","音乐"],"categories":["编程"]}]