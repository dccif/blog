[{"title":"博客的一键部署2","url":"/2021/11/07/博客的一键部署2/","content":"\n# 博客的一键部署2\n\n承接以前的 [**博客的一键部署**](https://blog.dccif.top/2017/11/27/%E5%8D%9A%E5%AE%A2%E7%9A%84%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2/)\n\n时隔几年，我又开始写博客了，这次一开始还是纠结了是选用传统的动态博客还是静态博客，考虑的价钱和安全性的问题，可能还是静态博客更适合我目前的阶段\n\n\n\n## 曾经的一键部署不好用了吗？\n\n的确曾经我的一键部署把简单的问题复杂了，想着利用一个仓库的两个分支保存原始文件和生成文件。的确这没有问题，目前我的博客也是这个方式，但是有问题的是我过去的整个工作流程。曾经我的流程完全和现在相反，难怪当初的用法那么难受😂\n\n\n\n## 现在的方法\n\n用现在Modern一点的词来说，就是现在使用了**持续集成 ( Continuous integration )**, 毕竟博客这种*项目*也算一种**持续交付（Continuous delivery）**，**持续部署（continuous deployment）**，只不过现在我只需写文章，然后推送，现代的在线工具就可以完成部署任务了，可以说能让我更专注于写作了。不过如果要长时间保持产出干货文章还是有点难度的啊，还是评说评说游戏什么的好了🤣\n","tags":["环境搭建"],"categories":["编程"]},{"title":"甘雨骗局","url":"/2021/05/09/甘雨骗局/","content":"\n# **随着难度的提高，其实月卡平民不该硬练(投入过量资源)甘雨**\n\n随着活动的结束，和深渊“开荒”的结束，很多玩家无脑吹上了甘雨，但是我认为甘雨其实是最不平民的角色，她是给平民保下限的角色。\n如果难度进一步增大，可能一些0命上限高的角色才是最适合月卡平民的。现在新出的优菈，胡桃，公子论dps是平民手上最强的\n\n首先我给出平民的定义: 满精4星武器0命5星角色，拿着5星武器甚至专属武器的就不要来“代入”了\n\n## 甘雨不适合平民的理由：\n\n<!--more-->\n\n### 1. 甘雨的提升难\n\n   练过的玩家肯定知道所谓的“一箭”多少w的提升有多难，冰套的“垃圾”词条有多少，乐团还没有稳定的获取途径。而且就算你阳寿，我们看武器都能看出，阿莫斯的精炼提升有多高，高精阿莫斯一箭大约能8w，而平民4w可能都难，逼真大佬的输出是平民的2倍。\n\n   有人就说了，其他角色也这样啊？可是问题就是其他反应角色可以依靠反应“拉近”和氪佬的距离，而甘雨单射的时候就和氪金多少有关系。\n   举一下那些核弹角色的例子，莫娜，公子，胡桃这几位，因为现在就能轻松打反应，所以哪怕平民玩家也能打出“大数字”。\n   大数字是有一定意义的，因为一般深渊难的怪就1，2只，靠大数字秒了，就是能不能过，和超不超时的区别。\n   现版本因为配套设施的问题，甘雨打融化并不容易，或者说比较别扭，既没全火力(吃满阿莫斯)的队友，也没融化冰套，只能捡“阳寿”圣遗物。\n\n\n\n### 2. 甘雨的队友难\n\n   大家都知道莫甘温娜的阵容，可是同样的主c阵容里，甘雨需要的队友是5星最多的，她需要的那位四星还是可有可无的。其他的主c都没她这么高的队友要求。\n\n   而另一种双火融化流，可能也需要钟离或者盾角色。比起其他主c全靠完善的4星就能配，她其实是最吃队友的。\n\n\n\n### 3. 甘雨的操作难\n   手机上蓄力射击有多难，不用多说了吧。可是同样别的主c手机上也能方便玩，pc上也方便。你说玩大招流，可是莫甘温娜终究是看ch愿不愿意抬和限制的问题，这阵容对单，比如1.6的古岩龙蜥就等于没有。\n\n\n\n### 4. 平民甘雨站场射击dps并不高\n   如果全程只靠平民甘雨战场射击，就算你弹无虚发，算下来的dps可能就2w射击+ 冰锥的1w，总计3w左右。\n   这里说的是dps：射击4w，需要1.8s，实战一般要2s，冰锥一般6000，实战1s3下左右，dps相加3w8\n   这是在一个4人游戏，可能还需要一个套盾人。意味着平民玩家让甘雨单战场需要吃2个队伍的位置，换来的dps就3w，而这个dps是很多2人角色都可以轻松超过的。\n   不和dps天花板胡桃比，就和迪卢克或者可莉比，其实都没优势。比如迪卢克，因为依靠平a可以触发后台副c，最典型的就是行秋。可莉走a重也能接近。\n   甘雨蓄力重击在平民玩家手上是不如高练后台2人的，最关键的上面的1点，平民甘雨提升难，其他能搭配副c的角色，提升输出难度就比甘雨容易。\n\n\n\n### 5. 平民甘雨不主c当后台冰工具人还不行了？\n   首先现在后台冰工具人的用途不算大，也不算抢手，不然早在开服时候为什么大家不练起来凯亚呢？而且平民甘雨要“无缝”大是需要堆充能的，势必会让dps更低。在不聚怪的情况下，平民甘雨可能q对单的总伤有10w左右，这输出分配到15s里，dps就7000左右，这个dps其实高练度的脱手，比如大家总“看不上”的阿贝多，都能做到。\n\n\n\n### 6. 甘雨可能是命座拆分最大的角色之一\n   不知道为什么甘雨命座竟然没“节奏”，也许只是大家看0命“大数字”就觉得强了吧。\n   甘雨命座藏了充能，生存，辅助，爆发。最关键的是爆发，当初迪卢克为什么被大家说呢？不就是爆发低了吗，甘雨把“爆发”机制藏进了命座。而其他的限定五星C 0命基本上都是又能爆发又能站场的。\n\n\n\n## 总结\n综上，甘雨吹们和平民玩家都冷静一点，平民配置下的她强度可能是跟不上“璃月3C”的名号的，也不是所谓的有了能解决一切烦恼的角色。\n\n那些还没甘雨的玩家也别因为“复刻”时真有了，感觉和“想象”中有差距就好了。\n\n真正适合平民的队伍可能还是高命的4星队伍，因为高命4星命座有伤害也有机制和配合，打过一个0命5星的队伍现在也不是什么稀奇的事吧。\n","tags":["角色评价","理解交流"],"categories":["原神"]},{"title":"关于《疯狂系列》","url":"/2018/02/24/关于《疯狂系列》/","content":"\n# 关于《疯狂系列》\n\n首先感谢李刚老师的《疯狂HTML5》的一书，本文以下的内容也是基于这本目前我看完的书得出的，作为对比的是《Head First HTML5》。\n\n下面我就从我暂时能想到的几个方面来谈谈这本《疯狂HTML5》或者同样的《疯狂系列》和《Head Fist》系列的对比吧。\n\n<!--more-->\n\n## 目标受众\n\n很多人评价书时没有注意到这本书是写个谁的，举个不恰当的例子，就像小学生买了高数书，然后说这本书不好，这样对书的评价我觉得是不客观的，也是不公平的，我竟然从这两个系列面向的不同的受众说说吧，当然本来我的水平也不高😅\n\n\n|      《疯狂系列》      | 《Head First》 |\n| :--------------------: | :------------: |\n| 已经从事软件开发的人员 | 还未入门的人士 |\n\n这不是我说的，是这两本书前言自己写的。\n\n所以有人拿着一本《疯狂系列》然后说没法入门，是本~~垃圾~~书我个人觉得是有失客观的。\n\n## 内容深度和广度\n\n说到一本入门级的书，到底要到什么程度？每个人有自己的看法，但是就书的广度来说，《疯狂系列》不愧是看完之后还能作作参考书的“入门书”，而《Head First》更像一个领路人，告诉读者这里可以这样，原理是什么。\n\n所以就我看的这一本来说\n\n深度：《疯狂》部分 <≈，其余 >《Head First》\n\n广度：《疯狂》>《Head First》\n\n### 暂时的结语\n\n所以如果我推荐，还是两本都看看，不重要的可以先跳过，但是《Head First》要先看，之后再看《疯狂系统》\n\n当然最好的入门还是best practices，在做的过程中学得最快。","tags":["阅读","编程"],"categories":["随想"]},{"title":"致过去的一年","url":"/2018/01/02/致过去的一年/","content":"\n# 致过去的一年\n\n眨眼间，2017就过去了，回首这一年，也许我最大的收获就是发现了自己有多弱了吧。从编译到算法，从语言到实现，我看上去每一门都知道那么一点，可是却又都不都不深入，也没自己实现过大一点的项目。","tags":["闲谈"],"categories":["随想"]},{"title":"近期随想","url":"/2017/12/18/近期随想/","content":"\n# 近期的随想\n\n自从我上次写好一键脚本后，过了快半个月，我却完全没有因为有了方便的脚本而增加写文产量😥，于是打算今天写一篇，并说说今日的学习记录吧。\n\n## 学习的一些心得\n\n最近因为Java Web中要使用Java而又对Java不太熟悉的我，翻出了以前库存的一大批书中，写给Java新人的书\n\n《Head First Java》顿时有种相见恨晚的感觉，这书有些难度又不失趣味的介绍了Java的核心思想和技术，对于我这种要巩固Java应用与提高使用水平的我来说，如一盏明灯，在Java的世界中给我照亮了一片前进与深入的方向，请允许我这这里用这种修饰来表达我对这本书的赞誉，虽然这和我以前的博文风格有着极大的不同😅，但是我相信读者朋友（如果有的话）一定可以感受出这本书，或者说这一系列书对我的帮助（下面会说Head First一系列的书），在此，我真的给每一位在自我感觉在入门到中高级的朋友推荐Head First系列的书。","categories":["清单"]},{"title":"博客的一键部署","url":"/2017/11/27/博客的一键部署/","content":"\n# 博客的一键部署\n\n终于在一番折腾和学习下，我用”三脚猫“的水平写了一个能一键写博客的脚本😂，这样以后写博客我只需要想写什么东西了，不用再在部署上折腾了。。。\n\n## 为什么要折腾\n\n说来这么折腾的写博客，也是我自找没趣。。。承接[《博客的备份》](https://blog.dccif.top/2017/10/23/%E5%8D%9A%E5%AE%A2%E5%A4%87%E4%BB%BD-Git%E5%B0%8F%E6%8A%80%E5%B7%A7/)，我这的写作环境我备份了好多份，每次要在这么多环境之间选择那些可见，那些不可见太麻烦了。。。写脚本的目的也是为了这个，当然脚本我是存在私有仓库的😋~~(写得太烂不好意放出来丢人现眼)~~\n\n","tags":["环境搭建"],"categories":["编程"]},{"title":"数组扩展的效率","url":"/2017/11/04/数组扩展的效率/","content":"\n# 数组扩展的效率差异\n\n说来惭愧，我现在才开始认真的学习算法和程序的效率😓。\n\n本文是我在阅读\n\n> **Data Structures,Algorithms,and Applications in C++** Second Edition\n> *Sartaj Sahni*\n\n遇到的一个小细节，与数组扩展的效率差异的原理。\n\n<!--more-->\n\n# 原始代码\n\n```c++\ntemplate<class T>\nvoid arrayList<T>::insert(int theIndex, const T& theElement)\n{// Insert theElement so that its index is theIndex.\n   if (theIndex < 0 || theIndex > listSize)\n   {// invalid index\n      ostringstream s;\n      s << \"index = \" << theIndex << \" size = \" << listSize;\n      throw illegalIndex(s.str());\n   }\n\n   // valid index, make sure we have space\n   if (listSize == arrayLength)\n      {// no space, double capacity\n         changeLength1D(element, arrayLength, 2 * arrayLength);\n         arrayLength *= 2;\n      }\n\n   // shift elements right one position\n   copy_backward(element + theIndex, element + listSize,\n                 element + listSize + 1);\n\n   element[theIndex] = theElement;\n\n   listSize++;\n}\n```\n\n不知道各位有没有觉得奇怪，为什么**12-16**行是当空间不足的时候，数组空间翻倍呢？\n\n同样的问题书上也提供了解答。。。。不过也许是我数学基础太差了，一时半会没理解😥\n\n本文也参考了*Stack Overflow*上的[Efficiency of growing a dynamic array by a fixed constant each time?](https://stackoverflow.com/questions/19146037/efficiency-of-growing-a-dynamic-array-by-a-fixed-constant-each-time)\n\n## 背后原理\n\n这就要用的数学知识了\n\n让我们假设现在有一个初始长度为1的空数组，需要执行$$n=2^k+1$$\n\nn次的插入操作，每次都在尾部插入。\n\n于是，每次插入我们都不需要移动已经存在的元素，n次插入的时间是Θ(n)加上数组扩展长度的时间。\n\n### 数组每次增加1的情况\n\n如果数组每次增加1，那么增加数组长度的时间为\n$$\\Theta (\\sum _{i=1}^{n-1} i)=\\Theta(1+2+3+4+...+(n-1))=\\Theta(\\frac{n(n-1)}{2} )=\\Theta(n^2)$$\n\n利用等差数列的公式，得到，如果数组每次长度增加1，n次插入的总时间是Θ(n^2)。\n\n### 数组每次翻倍的情况\n\n下面来解释为什么原始代码中的数组扩展使用的翻倍\n\n如果数组长度每次增倍，那么改变数组长度的时间是\n\n$$\\Theta(\\sum _{i=0}^k 2^i)=\\Theta(2^0+2^1+2^2+...+2^k)=\\Theta(2^{k+1}-1)$$\n\n$$k={\\log _2(n-1)}$$\n\n$$\\Theta(2^{k+1}-1)=\\Theta(2^{\\log _2(n-1)+1}-1)=\\Theta(2n-3)=\\Theta(n)$$\n\n利用等比数列公式，得到，如果每次数组长度翻倍，n次插入的总时间是Θ(n)。\n\n### 推论\n\n从数组每次翻倍的情况的公式，我们可以看出如果我们总是在原数组上按一个乘法因子来倍增，得到的总时间都是是Θ(n)\n\n这也是为什么[原始代码](#原始代码)中使用的是把长度翻倍的原因。\n","tags":["细节"],"categories":["算法"]},{"title":"Ubuntu的个性化配置","url":"/2017/10/27/Ubuntu的个性化配置/","content":"\n# Ubuntu下的个性化配置\n\n因为使用Linux开发方便的缘故，我在虚拟机上用全性能搭建了一个Ubuntu环境~~(别问我为什么不装双系统)~~\n\n于是和之前那篇Windows的重装一样，也想写一篇文章记录一下，以后搭建时可以方便一些\n\n<!--more-->\n\n## Java环境\n\n本文参考[How To Install Java with Apt-Get on Ubuntu 16.04](https://www.digitalocean.com/community/tutorials/how-to-install-java-with-apt-get-on-ubuntu-16-04)\n\n这里是Java8\n\n添加Oracle's PPA\n\n```shell\nsudo add-apt-repository ppa:webupd8team/java\nsudo apt-get update\n```\n\nThen, depending on the version you want to install, execute one of the following commands:\n\n### Oracle JDK 8\n\n```shell\nsudo apt-get install oracle-java8-installer\n```\n\n### Linux下的添加Java环境变量\n\nMany programs, such as Java servers, use the `JAVA_HOME` environment variable to determine the Java installation location. To set this environment variable, we will first need to find out where Java is installed. You can do this by executing the same command as in the previous section:\n\n```shell\nsudo update-alternatives --config java\n```\n\nCopy the path from your preferred installation and then open `/etc/environment` using `nano` or your favorite text editor.\n\n```shell\nsudo nano /etc/environment\n```\n\nAt the end of this file, add the following line, making sure to replace the highlighted path with your own copied path.\n\n/etc/environment\n\n```shell\nJAVA_HOME=\"/usr/lib/jvm/java-8-oracle\"\n```\n\nSave and exit the file, and reload it.\n\n```shell\nsource /etc/environment\n```\n\nYou can now test whether the environment variable has been set by executing the following command:\n\n```\necho $JAVA_HOME\n```\n\n\n\n## 开发环境\n\nVim-gtk 官方源已经有最新的了，直接apt install 就行了\n\nEmacs (需要手动添加源)\n\n```shell\nsudo add-apt-repository ppa:kelleyk/emacs\nsudo apt update\nsudo apt install emacs25\n```\n\n其余jetbrains全家桶，因为没有VS只好用Clion了\n\n\n\n## oh-my-zsh配置zsh\n\nubuntu默认不是zsh，输入下面命令安装 zsh\n\n```shell\nsudo apt-get install zsh\n```\n\n接下来我们需要下载 oh-my-zsh 项目来帮我们配置 zsh，注意此时一定要用 超级权限。\n\n```shell\nwget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh\n```\n\n查看你的zsh位置，输入\n\n```shell\ncat /etc/shells\n```\n\n```shell\n➜  ~ cat /etc/shells\n# /etc/shells: valid login shells\n/bin/sh\n/bin/dash\n/bin/bash\n/bin/rbash\n/bin/zsh\n/usr/bin/zsh\n➜  ~ \n```\n\n更改默认 shell，输入\n\n```shell\nsudo vim /etc/passwd\n```\n\n更改 root 和用户默认 shell\n\n```shell\nroot:x:0:0:root:/root:/usr/bin/zsh\nsong:x:1000:1000:song,,,:/home/song:/usr/bin/zsh\n```\n\nzsh 的配置文件是在用户目录下的 .zshrc\n\n每一行的配置前面都有#号,如果想要配置生效,去掉 #号即可.\n\n## 补全插件 incr.zsh\n\n这个插件的官网是: [Incremental completion on zsh](http://link.zhihu.com/?target=http%3A//mimosa-pudica.net/zsh-incremental.html)\n\n最新版本是 incr-0.2.zsh \n\n新建一个 incr-0.2.zsh 文件把他放进 用户目录下的 .oh-my-zsh/plugins/incr 目录下，没有的目录自己新建，其实放哪都一样。\n\n分别编辑 root 目录下的 .zshrc 和用户目录下的 .zsnrc\n\n加上一句\n\n```shell\nsource /home/song/.oh-my-zsh/plugins/incr/incr-0.2.zsh\n```\n\n/home/song/.oh-my-zsh/plugins/incr 是你放的不同的目录。\n\n最后还有一个小问题，原来我们用的 超级用户创建的 oh-my-zsh 导致 .oh-my-zsh 目录下的缓存目录 cache 所有者和用户组也是root 这样就导致我们在普通用户下使用有些问题，下面改变 cache的所有者\n\n输入\n\n```shell\nchown song:song cache/ -R\n```\n\n这样就不会在命令提示时候弹出错误了。\n\n","tags":["环境搭建"],"categories":["清单"]},{"title":"博客备份-Git小技巧","url":"/2017/10/23/博客备份-Git小技巧/","content":"\n# Hexo博客的备份\n\n可能是因为被害妄想症的原因吧，我怕博客的丢失，在我的硬盘，电脑和GitHub和私有服务器上备份了四份，在本博客的仓库的Public分支上就是我的博客文章的备份\n\n<!--more-->\n\n## 为什么要备份\n\n备份的重要性我觉的不用我说了吧，为了防止数据的丢失 ~~虽然好像没什么宝贵的数据~~\n\n其实是突然发奇想想利用Git的分支来在一个仓库管理我的博客\n\n## 为什么只备份文章\n\n毕竟文章本来就是给各位看的，但是私人的配置文件中有个人APIKey和一些个性化设定，这些可不好Public了😃\n\n## Git小技巧\n\n因为这次忽略文件是我临时添加的，再修改了**.gitignore**文件后在次上传并没有生效\n\n感谢pfeng的作者，本文参考http://www.pfeng.org/archives/840\n\n在**git**中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 **.gitignore** 文件的方法（如无，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：\n\n\n```shell\n# 此为注释 – 将被 Git 忽略\n*.a         # 忽略所有 .a 结尾的文件\n!lib.a      # 但 lib.a 除外\n/TODO`      # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO\nbuild/      # 忽略 build/ 目录下的所有文件\ndoc/*.txt   # 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt\n```\n规则很简单，不做过多解释，但是有时候在项目开发过程中，突然心血来潮想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是**.gitignore**只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改**.gitignore**是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：\n```shell\ngit rm -r --cached .\ngit add .\ngit commit -m 'update .gitignore'\n```","tags":["细节"],"categories":["编程"]},{"title":"重装系统程序清单","url":"/2017/10/16/重装系统程序清单/","content":"# 因为种种原因\n我不得不重装我这用了快3年的电脑，心里一阵苦，本清单用于个人重装系统后的恢复工作，日后也能参考\n\n\n\n# 驱动安装\n~~这步我就不说了~~\n\n这个周末被这个折腾的够呛，我觉得还是有必要说一下了😭\n\n<!--more-->\n\n首先说下我遇到的坑吧，现在事后说起来觉得好蠢，可以当我遇到的时候真是百思不得其解。\n\n这次我遇到的坑一句话就是驱动的冲突，我原本的罗技鼠标和这个国产软件----驱动精灵，检测出来的不一样，于是就给我装了一个雷蛇的驱动。。。关键是我装好了之后还没法卸载。导致的现象就是每次开机我都要手动用管理员权限打开罗技的`游戏软件`，也许是我强迫症吧，为了发现和解决这个问题，我重装了5次系统。。。\n\n\n\n好好的一个周末都被浪费掉了。。。\n\n收获就是国产的驱动软件不能完全相信。。，每一步安装前要先确认一下这个驱动是什么\n\n还有2个被土啬的驱动检测软件，这两个的驱动都是没有问题的，名字我就先不提了。\n\n## 程序清单\n没有链接的文件在个人备份的磁盘中\n### 语言环境\n1. [Java8](http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html)\n2. [Tomcat9](https://tomcat.apache.org/download-90.cgi)\n3. [Python](https://www.python.org/downloads/)\n4. [Node.js](https://nodejs.org/en/)\n5. **别忘了配置环境变量**\n\n### 开发工具\n#### 微软\n1. [Visual Studio](https://www.visualstudio.com/zh-hans/) (~~之所以重装都是因为这个巨无霸~~)\n2. [VIsual Studio Code](https://www.visualstudio.com/zh-hans/) (还好没有什么配置文件)\n#### GNU\n3. [Emacs](http://mirrors.ustc.edu.cn/gnu/emacs/windows/)，GVIM (硬盘中拷备份件)\n4. [Git](https://git-scm.com/download/win)\n5. [GitHub Desktop](https://desktop.github.com/)\n#### JetBrains\n4. [Intellij IDEA](https://www.jetbrains.com/idea/)\n5. [Android Studio](https://developer.android.com/studio/index.html)\n6. [WebStorm](https://www.jetbrains.com/webstorm/?fromMenu)\n7. [PyCharm](https://www.jetbrains.com/pycharm/?fromMenu)\n#### 其他\n8. [Eclipse](http://www.eclipse.org/home/index.php)\n9. [DrRacket](https://racket-lang.org/download/)\n10. VMware Workstation Pro\n11. [wampserver](http://www.wampserver.com/en/)\n12. [Wireshark](https://www.wireshark.org/download.html)\n13. [Notepad++](https://notepad-plus-plus.org/download/v7.5.1.html)\n\n### 多媒体\n1. [Potplayer](https://potplayer.daum.net/)\n2. PDFX\n3. [foobar2000](http://blog.sina.com.cn/s/blog_6fcc51420102wv92.html)\n4. [Calibre](https://calibre-ebook.com/download)\n5. Sigil\n6. [Mp3tag](https://www.mp3tag.de/en/download.html)\n\n### 娱乐\n1. [Steam](http://store.steampowered.com/about/)\n\n### 学习\n1. GoldenDict\n2. wolfram mathematica\n3. [ManicTime](https://www.manictime.com/)\n\n### 效率工具\n1. [Everything](https://www.voidtools.com/downloads/)\n2. IDM\n3. [f.lux](https://justgetflux.com/)\n4. [Ditto](http://ditto-cp.sourceforge.net/)\n5. [Dism++](https://www.chuyu.me/zh-Hans/)\n6. [TeamViewer](https://www.teamviewer.com/zhcn/download/windows/)\n7. [Sumo](https://www.kcsoftwares.com/?download)\n8. [Wox](https://github.com/Wox-launcher/Wox/releases)\n9. TriDnet\n10. XYplorer\n11. Total Commander\n12. MySpeed\n13. [Listary](http://www.listary.com/download)\n14. [Input Director](https://www.inputdirector.com/downloads.html)\n15. Capture2Tex\n16. Process\n\n### SSH工具\n1. XX-net\n2. [Proxifier](https://www.echoteen.com/proxifier-newway.html)\n3. Xshell5 & Xftp\n4. [FileZilla](https://filezilla-project.org/)\n\n### 浏览器及插件\n1. [Chrome32bit](https://www.google.com/chrome/browser/desktop/index.html)\n  备份文件\n2. [Firefox](https://www.mozilla.org/zh-CN/firefox/desktop/)\n\n## 其余\n在个人备份硬盘中","tags":["环境搭建"],"categories":["清单"]},{"title":"IDEA下的Java Webapp环境搭建","url":"/2017/10/14/IDEA下的Java-Webapp环境搭建/","content":"# IDEA 下Java Webapp的环境搭建\n\n本文在以下环境搭建：\n> IntelliJ IDEA 2017.2.5\n> JDK 1.8.0_144\n> JRE: 1.8.0_152-release-915-b12 amd64\n> JVM: OpenJDK 64-Bit Server VM by JetBrains s.r.o\n> Apache Tomcat 9.0.1 Server\n> Windows 10 x64 15063.674\n\n**注意!!** 本文不包括JAVA环境及Tomcat的搭建！\n\n<!--more-->\n\n## 写文缘由\n\n可能有人问我既然不是写给新人看的，还不写重点的JAVA环境及Tomcat的搭建，你写这有什么用？那么你可以**Ctrl+w**了。因为现在网上的都是关于Eclipse或者老版本的IDEA的教程，所以想写一篇新的，顺带拉一波新人入IDEA的坑。\n\n~~个人不喜欢课堂上老师用的旧工具~~\n\n### 新建Project\n{% img /image/IDEA/newproject.jpg 新建项目 %}\n\n{% img /image/IDEA/select.jpg 选择应用module %}\n\n下一步随便给项目取一个名字\n\n### **下面是重点了**\n可能是我的环境太新了，和网上的教程生成的目录结构是不一样的。\n\n{% img /image/IDEA/struct.jpg 目录结构 %}\n\n我们要新建2个文件夹，都是在web/WEB-INF/目录下\n\n1. classes {% raw %}&nbsp&nbsp&nbsp&nbsp{% endraw %} --编译后的文件\n2. lib {% raw %}&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp{% endraw %} --以后要引入的库\n\n### 新的目录结构 {% img /image/IDEA/after.jpg 新建Servlet和新的目录结构 %}\n\n{% img /image/IDEA/newservlet.jpg 新建Servlet %}\n\n### 更改项目目录结构 {% img /image/IDEA/newstruct.jpg 更改目录结构 %}\n\n#### 更改out目录 {% img /image/IDEA/newout.jpg 更改out目录 %}\n\n#### 更改lib目录 {% img /image/IDEA/newlib.jpg 更改lib目录 %}\n\n#### 更改out结构 {% img /image/IDEA/outset.jpg 更改out结构 %}\n\n### 配置服务器 {% img /image/IDEA/configserver.jpg 配置服务器 %}\n\n{% img /image/IDEA/setserver1.jpg %}\n\n{% img /image/IDEA/setserver2.jpg 配置服务器 %}\n\n## 测试代码\n\nJsp 测试：\n\n```Jsp\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title>简单的JSP页面</title>\n</head>\n<body>\n<h1>Hello,World!</h1>\n现在的时间是: <%= new java.util.Date() %>\n</body>\n</html>\n```\n结果：\n\n{% img /image/IDEA/result1.jpg Jsp页面测试 %}\n\n\n\nServlet 测试：\n\n```java\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n@WebServlet(name = \"HelloServlet\", urlPatterns = {\"/helloServlet.do\"})\npublic class HelloServlet extends HttpServlet {\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        response.setContentType(\"text/html;charset=UTF-8\");\n        PrintWriter out = response.getWriter();\n        out.println(\"<html>\");\n        out.println(\"<head><title>当前时间</title></head><body>\");\n        out.println(\"<h3>Hello,World!</h3>\");\n        out.println(\"现在时间是：\" + new java.util.Date());\n        out.println(\"</body>\");\n        out.println(\"</html>\");\n    }\n}\n```\n\n结果：\n{% img /image/IDEA/result2.jpg Servlet测试 %}\n\n## 搭建完成\n至此完成了在IDEA上Servlet的环境搭建。\n\n~~你以为接这样结束了？~~\n\n你难道想每次都按怎么多才能搭建好环境？\n~~其实可以选择Maven的，但是Maven更难掌握~~\n有个简单的方法能节省几步以后搭建的操作\n\n### 保存模版\n\n{% img /image/IDEA/savetemp.jpg 保存模版 %}\n\n之后就能看到了\n\n{% img /image/IDEA/usertemp.jpg 用户模版 %}\n\n然而这个功能支持Java项目并不完美，所以以后每次都要新建两个文件夹，就是classes和lib，但之后的目录结构设置会自动完成的\n","tags":["环境搭建"],"categories":["编程"]},{"title":"Prologue","url":"/2017/10/10/Prologue/","content":"# 一些闲话来作为我博客的序章吧\n\n可以说是“**机缘巧合**”吧，我从原来的自建服务器迁移到了[**GitHub Pages**](https://pages.github.com/)上，具体的原因我绝的可以留到下一篇博文再说了😜\n\n## 写作的缘由\n\n在一番折腾之后终于搭成了这个博客，想着也不能浪费，于是就来写写东西了，主要也是个人生活或者学习的记录。不过鉴于我个人的水平，如果有读者有幸看到这篇文章的话，那么也请别抱太大的希望，因为我本质上还是一个`理工男`。在本博客中你可能看不到什么精彩的文风或者犀利的批判。\n\n<!--more-->\n\n## 本博客以后和现在的内容\n\n想了半天也不知道和清楚写什么，于是就想先介绍一下博客好了。\n\n以后包括未来博主主要写的文章大多是\n\n1. 编程类\n2. 细节类\n3. 感想类\n4. 推荐类\n\n下面就来细说一下好了。~~我又想到扯得东西了~~\n\n### 编程类\n\n因为本人专业和兴趣的原因，我还是写的编程的多点，因为这个博客我也想当成我学习编程的成长记录吧。\n\n### 细节类\n\n怎么定义呢？说实话我也很难说什么属于细节，只是因为以前写的文章算是细节，便单独开了一个目录了，因为我现在的编程学习，个人还是理论派，看的书比写的码多，于是便把一些书上好的地方记录下来，日后也许可以写一些物品在实践中处理问题遇到的细节。\n\n### 感想类\n\n虽然我现在一篇此类的文章都没写，但是我觉得一个博客之所以能叫博客就是因为能抒发作者自己的想法，所以我的博客也不例外，如果没有这个类的话，我的博客就不能说是我的博客了，只能说是一些零散知识的拼凑。\n\n### 推荐类\n\n个人觉得这也许是我以后写的最多的文章了，因为个人对新奇软件和数码的喜好，我个人会推荐和介绍一些本人正在使用的好的软件或硬件，甚至是上文编程类中的好东西，当然这也是否考验功力，你凭什么推荐这个？","tags":["闲谈"],"categories":["随想"]},{"title":"递归的两种优化方法","url":"/2017/10/10/递归的两种优化方法/","content":"# 递归（Recursion）的两种优化方法\n\n最近学习了一些递归的优化方法，于是想写一篇文章记录一下，方便以后查看，并想分享一下。\n虽然平日的上课中老师都是建议我们不要使用递归，但是在**函数式编程（functional programming）**中递归是很常用的，而且掌握递归的思想有时能让我们找到最优解。\n\n<!--more-->\n\n## 1. 最经典的斐波那契数列\n\n```c\nint Fibonacci(int n) {\n    if (n == 1 || n == 2) {\n        return 1;\n    }\n    else\n    {\n        return Fibonacci(n - 2) + Fibonacci(n - 1);\n    }\n}\n```\n\n这个算法一般计算到40左右就不行了，因为运行栈已经被函数的递归调用占满了\n\n## 2. 尾递归（Tail Recursive）\n\n传说中的[**尾递归**](https://www.wikiwand.com/zh/%E5%B0%BE%E8%B0%83%E7%94%A8)。具体我不细说了，就是上一个版本的优化，每次调用函数时不生成新的运行栈，利用上一次的结果\n**注意：**不是所有语言都有**尾递归**优化的（Java就没有）\n       也不是所有算法都能写成**尾递归**的形式的\n\n``` c\nint fiboTail(int n, int acc, int cal) \n//acc充当收集器的左右，收集上一次运行栈的返回值，因为之后栈空间会被回收\n//cal是每一次递归的计算\n{\n    if (n == 1) return acc;\n    if (n == 2) return cal;\n    return fiboTail(n - 1, cal, acc+cal);\n}\n```\n\n可以看到尾递归的函数比原始的版本多了2个参数，一个起到**收集器（accumulator)**的作用，记录每上一次栈的返回值，因为原来栈的空间会被下一层递归覆盖。\n还有一个参数就是每次递归的操作了，因为是斐波那契，所以这里是相加。\n\n尾递归的调用方法也与原来的不一样，因为斐波那契的初始值 ( 1. 1 . 2 . 3 ......)\n所以以下的调用，acc 要用初始值 1，cal 也要用第二位的值这里也是1\n调用的方法就是  **fiboTail(n, 1，1）**\n尾递归的方法计算基本上是秒出的，可是比起下面一种方法还是要慢，就是在32位机器上要注意 **int范围** 第47位已经超过int的表示范围了\n\n## 3. 利用缓存\n\n典型的空间换时间\n\n``` c\nenum { gnFib = 99 };\nint gFib[gnFib];      // 生成一个数组记录已经生成的斐波那契数\n\nint fib(int n)\n{\n    if (n < 0 || n >= gnFib) return 0;\n    int &fn = gFib[n];   \n    if (!fn) {            //如果当前数不在数组中才计算\n        if (n == 0 || n == 1) fn = 1;\n            else fn = fib(n - 1) + fib(n - 2);\n    }\n    return fn;\n}\n```\n\n核心思想就是利用之前信息，每次递归不用再重新计算了\n","tags":["优化"],"categories":["编程"]},{"title":"短路求值(Short-circuit evaluation)","url":"/2017/10/10/短路求值-Short-circuit-evaluation/","content":"# 短路求值\n\n> Short-circuit evaluation\n\n最早是在**php**中接触到的这种求值，后来在学习**Lisp**中又一次接触到了，于是想写一篇文章记录一下，并分享一下，这个被我忽略的可能可以说是细节的点吧\n\n<!--more-->\n\n## 什么是**短路求值（Short-circuit evaluation）**\n\n以下摘自[Short-circuit evaluation](https://www.wikiwand.com/en/Short-circuit_evaluation)\n> **Short-circuit evaluation**, minimal evaluation, or McCarthy evaluation (after John McCarthy) is the semantics of some Boolean operators in some programming languages in which the second argument is executed or evaluated only if the first argument does not suffice to determine the value of the expression: when the first argument of the AND function evaluates to false, the overall value must be false; and when the first argument of the OR function \nevaluates to true, the overall value must be true.\n\n概况来说就是在求**布尔表达式**的时候程序并不会执行全部的**Expression**\n\n比如**AND**或者**OR**操作时如果后面第一个Expression为True，那么之后的Expression就不会再求值了。\n\n## 一些例子\n\n### 普通的**C**程序\n\n```c\nint denom = 0;\nif (denom != 0 && num / denom)\n{\n    ... // ensures that calculating num/denom never results in divide-by-zero error   \n}\n```\n\n### 使用了短路求值的**C**程序\n\n```c\nint a = 0;\nif (a != 0 && myfunc(b))\n{\n    do_something();\n}\n```\n\n在这个例子中**&&**后的**myfunc(b)**将永远不会执行，因为**a!=0**永远是**FALSE**。\n利用短路求值有2个有用的技巧\n\n 1. 如果条件判断的expression需要复杂的计算，并且第一个结果为**False**，则可以不计算之后的表达式\n 1. 可以构造一个expression来使第二个可能会发生运行时错误的expression成功运行\n\n```c\nbool is_first_char_valid_alpha_unsafe(const char *p)\n{\n    return isalpha(p[0]); // SEGFAULT highly possible with p == NULL\n}\n\nbool is_first_char_valid_alpha(const char *p)\n{\n    return p != NULL && isalpha(p[0]); // 1) no unneeded isalpha() execution with p == NULL, 2) no SEGFAULT risk\n}\n```\n\n这个例子避免了空指针\n\n### 最近学习的Lisp中的例子：\n\n```Lisp\n(defparameter *is-it-even* nil)\n(or (oddp 5) \n(setf *is-it-even* t))\n```\n\n利用短路求值，用**OR**实现了条件判断\n\n## 可能的问题：\n\n尽管有上面说的优点，但是可能会带来没有意识到的问题，比如：\n\n```c\nif (expressionA && myfunc(b)) {\n    do_something();\n}\n```\n\n当**expressionA**为**True**时无论**do_something()**是否执行，**myfunc(b)**都会执行，例如分配系统资源的操作。\n\n相反，**expressionA**为**False**时**myfunc(b)**永远不会执行\n\n## 支持的语言\n\n**并不是所有语言和所有操作符支持的**\nJava支持**非短路求值**也支持**短路求值**\n\n| 常见的语言 | 支持的操作符 |\n| :------- | :--------- |\n| C, Obejective-C, C++, C# | &&, ∥, ? |\n| Java, MATLAB, R, Swift | &&, ∥ |\n| JavaScript, GO, Haskel | &&, ∥ |\n| Lisp, Lua, Scheme | and, or |\n| PHP | &&, and, ∥, or |\n| Python | and, or |\n| Visual Basic | 不支持 |","tags":["细节"],"categories":["编程"]},{"title":"my test page","url":"/2017/10/10/my-test-page/","content":"# 个人测试页\n\n## 这是我的一个测试页面\n\n### 我也不知道写什么好\n"}]